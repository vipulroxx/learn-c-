head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.1;

1.1
date	2005.12.11.17.16.08;	author blep;	state Exp;
branches;
next	;


desc
@@


1.2
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#ifndef OPENTEST_CONNECTOR_H_INCLUDED
# define OPENTEST_CONNECTOR_H_INCLUDED

# include <opentest/forwards.h>
# include <opentest/interfaces.h>
# include <cpptl/thread.h>
# include <set>

namespace OpenTest {

   enum ConnectionStatus
   {
      connectionNotEstablished = 0,
      connectionEstablished,
      connectionInProcess
   };

   class OPENTEST_API ConnectionStatusListener
   {
   public:
      virtual ~ConnectionStatusListener()
      {
      }

      virtual void connectionStatusChanged( ConnectionStatus oldStatus,
                                            ConnectionStatus newStatus,
                                            const std::string &info ) = 0;
   };

   class OPENTEST_API Connector : public CppTL::IntrusiveCount
   {
   public:
      class Status
      {
      public:
         Status( ConnectionStatus status, 
                 const std::string &info )
                 : status_( status )
                 , info_( info )
         {
         }

         ConnectionStatus status_;
         std::string info_;
      };

      Connector()
         : status_( connectionNotEstablished )
         , version_( 0 )
         , driver_( 0 )
         , runner_( 0 )
      {
      }

      virtual ~Connector()
      {
         if ( driver_ )
            driver_->setConnector( 0 );
         if ( runner_ )
            runner_->setConnector( 0 );
      }

      void addListener( ConnectionStatusListener &listener )
      {
         CppTL::Mutex::ScopedLockGuard guard( lock_ );
         listeners_.insert( &listener );
         ++version_;
      }

      void removeListener( ConnectionStatusListener &listener )
      {
         CppTL::Mutex::ScopedLockGuard guard( lock_ );
         listeners_.erase( &listener );
         ++version_;
      }

      Json::Value properties() const
      {
         CppTL::Mutex::ScopedLockGuard guard( lock_ );
         return properties_;
      }

      //void setProperties( const Json::Value &properties )
      //{
      //   properties_ = properties;
      //}

      Status status() const
      {
         CppTL::Mutex::ScopedLockGuard guard( lock_ );
         return Status( status_, statusInfo_.str() );
      }

      void updateStatus( ConnectionStatus status,
                         const std::string &info = std::string() )
      {
         ConnectionStatus oldStatus;
         Listeners listenersToNotify;
         VersionId version;
         {
            CppTL::Mutex::ScopedLockGuard guard( lock_ );
            if ( status_ == status  &&  statusInfo_ == info )
               return;
            listenersToNotify = listeners_;
            oldStatus = status_;
            status_ = status;
            statusInfo_ = info;
            listenersToNotify = listeners_;
            version = version_;
         }

         Listeners notifiedListeners;
         while ( !listenersToNotify.empty() )
         {
            ConnectionStatusListener &listener = **(listenersToNotify.begin());
            listener.connectionStatusChanged( oldStatus, status, info );
            listenersToNotify.erase( &listener );
            if ( !listenersToNotify.empty() )
            {  
               notifiedListeners.insert( &listener );
               CppTL::Mutex::ScopedLockGuard guard( lock_ );
               if ( version != version_ ) // listener list changed
               {
                  listenersToNotify = listeners_;
                  listenersToNotify.erase( notifiedListeners.begin(), 
                                           notifiedListeners.end() );
                  version = version_;
               }
            }
         }
      }

      void attachTestDriver( TestDriverInterface &driver )
      {
         driver_ = &driver;
         driver_->setConnector( this );
      }

      void attachTestRunner( TestRunnerInterface &runner )
      {
         runner_ = &runner;
         runner_->setConnector( this );
      }

      TestDriverInterface &testDriver()
      {
         return *driver_;
      }

      TestRunnerInterface &testRunner()
      {
         return *runner_;
      }

      virtual void establishConnection() = 0;

      virtual void disconnect() = 0;

   private:
      typedef std::set<ConnectionStatusListener *> Listeners;
      Listeners listeners_;
      mutable CppTL::Mutex lock_;
      Json::Value properties_;
      CppTL::ConstString statusInfo_;
      ConnectionStatus status_;
      TestRunnerInterface *runner_;
      TestDriverInterface *driver_;
      typedef volatile unsigned int VersionId;
      VersionId version_;
   };


   class OPENTEST_API DirectConnector : public Connector
   {
   public:
      DirectConnector( TestRunnerInterface &runner,
                       TestDriverInterface &driver )
      {
         attachTestRunner( runner );
         attachTestDriver( driver );
      }

   public: // overridden from Connector
      virtual void establishConnection()
      {
         updateStatus( connectionEstablished, "direct connection" );
      }

      virtual void disconnect()
      {
         updateStatus( connectionNotEstablished, "disconnected" );
      }
   };

   } // namespace OpenTest

#endif // OPENTEST_CONNECTOR_H_INCLUDED
@


1.1
log
@* rough sketch of a working OpenTest driver with CppUT adaptor for TestRunner.
@
text
@@

