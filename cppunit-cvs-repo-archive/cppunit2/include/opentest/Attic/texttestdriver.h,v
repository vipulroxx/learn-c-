head	1.14;
access;
symbols
	CPPUNIT2_TG_AFTER_CONSTSTRING:1.8
	CPPUNIT2_TG_BEFORE_CONSTSTRING:1.7
	TG_AFTER_REMOVING_TESTCONTEXT:1.4
	TG_BEFORE_MOVING_ASSERT_TO_TESTINFO:1.3
	TG_BEFORE_REMOVING_TESTCONTEXT:1.2;
locks; strict;
comment	@ * @;


1.14
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.13;

1.13
date	2006.03.06.22.50.53;	author blep;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.06.21.56.17;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.11.17.49.18;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.28.22.11.55;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.28.20.54.45;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.27.10.15.57;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.26.11.45.06;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.23.23.04.34;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.21.22.27.15;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.20.15.07.00;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.19.21.39.13;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.16.22.46.44;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.15.08.34.13;	author blep;	state Exp;
branches;
next	;


desc
@@


1.14
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#ifndef OPENTEST_TEXTTESTDRIVER_H_INCLUDED
# define OPENTEST_TEXTTESTDRIVER_H_INCLUDED

# include <opentest/connector.h>
# include <opentest/interfaces.h>
# include <stdio.h>


namespace OpenTest
{
   class TextTestDriver : private TestDriverInterface
   {
   public:
      TextTestDriver( int argc, const char *argv[] )
      {
      }

      virtual ~TextTestDriver()
      {
      }

      void addTestRunner( TestRunnerInterface &testRunner )
      {
         addConnector( new DirectConnector( testRunner, *this ) );
      }

      void addConnector( const ConnectorPtr &connector )
      {
         connectors_.push_back( connector );
      }

      bool runTests()
      {
         for ( Connectors::iterator it = connectors_.begin();
               it != connectors_.end();
               ++it )
         {
            Connector &connector = **it;
            if ( connector.status().status_ != connectionEstablished )
               connector.establishConnection();
         }

         for ( Connectors::iterator it2 = connectors_.begin();
               it2 != connectors_.end();
               ++it2 )
         {
            Connector &connector = **it2;
            if ( connector.status().status_ == connectionEstablished )
            {
               connector.testRunner().getTestDescriptions();
               connector.testRunner().getTestPlans();
               connector.testRunner().runTests(plans_);
            }
         }
         return 0;
      }

   private: // overridden from TestDriverInterface
      virtual void setTestDescriptions( const TestDescriptions &tests )
      {
         descriptions_ = tests;
      }

      virtual void setDefaultTestPlans( const TestPlans &plans )
      {
         plans_ = plans;
      }

      virtual void startTesting( TestPlanId testPlan )
      {
         printf( "Start testing: %s\n", getTestCaseDesc( testPlan ).name_.c_str() );
      }

      virtual void addResultLog( TestPlanId testPlan, 
                                 const ResultLog &log )
      {
         printf( "Log for %s:\n", 
                 getTestCaseDesc( testPlan ).name_.c_str() );
      }

      virtual void addResultAssertion( TestPlanId testPlan, 
                                       const ResultAssertion &assertion )
      {
         printf( "- Assertion for %s:\n"
                 "Type:%s\n"
                 "Message:\n%s\n", 
                 getTestCaseDesc( testPlan ).name_.c_str(),
                 assertion.assertionType_.c_str(),
                 assertion.message_.c_str() );
      }

      virtual void setResultInputActualOutput( TestPlanId testPlan, 
                                               const ResultInputOutput &output )
      {
      }

      virtual void setTestResult( TestPlanId testPlan, 
                                  const ResultStatus &status )
      {
         printf( "Result for %s:\n%s\n", 
                 getTestCaseDesc( testPlan ).name_.c_str(),
                 status.status_.c_str() );
      }

      virtual void testPlanDone( TestPlanId id )
      {
      }

   private:
      OpenTest::TestCaseDescription &getTestCaseDesc( TestPlanId testPlan )
      {
         TestId testId = plans_.testPlans_.at( testPlan ).testCase_;
         TestDescriptions::TestCases::iterator it = descriptions_.testCases_.find( testId );
         if ( it == descriptions_.testCases_.end() )
            throw std::runtime_error( "Invalid test plan" );
         return it->second;
      }

      typedef std::deque<ConnectorPtr> Connectors;
      Connectors connectors_;
      OpenTest::TestPlans plans_;
      OpenTest::TestDescriptions descriptions_;
   };
};


#endif // OPENTEST_TEXTTESTDRIVER_H_INCLUDED

@


1.13
log
@* fixed msvc6 compilation issues
@
text
@@


1.12
log
@* fixed compilation issue with gcc
@
text
@d43 3
a45 3
         for ( Connectors::iterator it = connectors_.begin();
               it != connectors_.end();
               ++it )
d47 1
a47 1
            Connector &connector = **it;
@


1.11
log
@* reorganized code a bit
@
text
@d32 1
a32 1
      void runTests()
d55 1
@


1.10
log
@* moved texttestdriver.h class implementations into a .cpp
@
text
@d4 3
a6 7
# include <opentest/properties.h>
# include <opentest/testplan.h>
# include <opentest/testrunner.h>
# include <cpptl/enumerator.h>
# include <deque>
# include <map>
# include <set>
a7 1
namespace OpenTest {
d9 1
a9 1
class OPENTEST_API TestDriverTestPlan : public TestPlan
d11 1
a11 63
public: // overriden from TestPlan
   TestPlanEntryPtrEnum entries() const;

public:
   void add( const TestPlanEntryPtr &entry );

private:
   std::deque<TestPlanEntryPtr> entries_;
};


class OPENTEST_API TestResult
{
public:
   TestResult( TestPlanEntryId id, TestId test );

   TestPlanEntryId id() const;

   TestId test() const;

   const Properties &result() const;

   Properties &result();

private:
   TestPlanEntryId id_;
   TestId test_;
   Properties result_;
};


class OPENTEST_API TestDriverTestPlanEntry : public TestPlanEntry
{
public:
   TestDriverTestPlanEntry( TestPlanEntryId id,
                            TestId test,
                            const Properties &configuration );

public: // overriden from TestPlanEntry
   TestPlanEntryId id() const;

   /// Test to run
   TestId test() const;

   /// Used to pass configuration data to the test runner or the test itself
   const Properties &configuration() const;

private:
   TestPlanEntryId id_;
   TestId test_;
   Properties configuration_;
};

class TestInfo;
class TestCaseInfo;
class TestSuiteInfo;

typedef CppTL::AnyEnumerator<TestInfo> TestInfoEnumerator;

class TestInfoHolder
{
public:
   virtual ~TestInfoHolder()
d13 4
a16 1
   }
d18 3
a20 7
   virtual const String &getTestName( TestId id ) const = 0;
   virtual PropertiesAccessor getTestDescription( TestId id ) const = 0;
   virtual PropertiesAccessor getTestInput( TestId id ) const = 0;
   virtual bool isTestSuite( TestId id ) const = 0;
   virtual TestInfoEnumerator getTestChildren( TestId id ) const = 0;
   virtual TestInfoEnumerator getTestParents( TestId id ) const = 0;
};
d22 4
d27 4
a30 5
class OPENTEST_API TestInfo
{
public:
   TestInfo( const TestInfoHolder &holder,
             TestId id );
d32 24
a55 3
   virtual ~TestInfo()
   {
   }
d57 5
a61 18
   const String &getName() const;
   PropertiesAccessor getDescription() const;
   bool isTestSuite() const;
   bool isTestCase() const;
   TestInfoEnumerator getParents() const;

   // test case specifics
   PropertiesAccessor getInput() const;

   // test suite specifics
   TestInfoEnumerator getChildren() const;
   TestInfoEnumerator getChildTestSuites() const;
   TestInfoEnumerator getChildTestCases() const;

protected:
   const TestInfoHolder &holder_;
   TestId id_;
};
d63 4
d68 4
a71 6
class OPENTEST_API TestInfoExplorer
{
public:
   virtual ~TestInfoExplorer()
   {
   }
d73 6
a78 4
   virtual TestInfoEnumerator getAllTestCases() const = 0;
   virtual TestInfoEnumerator getAllTestSuites() const = 0;
   virtual TestInfo getRootTestSuite() const = 0;
};
d80 10
d91 4
d96 7
a102 7
class OPENTEST_API TextTestDriver : private TestRunTracker
                                  , private TestDeclarator
                                  , private TestInfoHolder
                                  , public TestInfoExplorer
{
public:
   TextTestDriver( TestRunner &runner );
d104 3
a106 15
//   void selectTest( const CppTL::ConstString &name );

   bool run();

public: // overridden from TestInfoExplorer
   TestInfoEnumerator getAllTestCases() const;
   TestInfoEnumerator getAllTestSuites() const;
   TestInfo getRootTestSuite() const;

private: // overridden from TestDeclarator
   TestId beginSuite( const CppTL::ConstString &name,
                      const Properties &data );

   TestId addTest( const CppTL::ConstString &name,
                   const Properties &data );
d108 2
a109 51
   void endSuite();

private: // overriden from TestRunTracker
   void startTestRun();

   void startTest( const TestPlanEntry &testEntry );

   void mergeInTestResult( const TestPlanEntry &testEntry,
                           const Properties &result );

   void mergeInTestResult( const TestPlanEntry &testEntry,
                           const PropertyPath &path,
                           const Value &value );

   void appendToTestResult( const TestPlanEntry &testEntry,
                            const PropertyPath &path,
                            const Value &value );

   void endTest( const TestPlanEntry &testEntry );

   void endTestRun();

   bool shouldStopTestRun();

   void aqcuireResources( const ResourceList &resources ) {}

   void releaseResources( const ResourceList &resources ) {}

private: // overridden from TestInfoHolder
   const String &getTestName( TestId id ) const;
   PropertiesAccessor getTestDescription( TestId id ) const;
   PropertiesAccessor getTestInput( TestId id ) const;
   bool isTestSuite( TestId id ) const;
   TestInfoEnumerator getTestChildren( TestId id ) const;
   TestInfoEnumerator getTestParents( TestId id ) const;

public:
   typedef std::deque<TestId> ParentSuites;

private:

   struct InternalTestInfo
   {
      InternalTestInfo( TestId id, 
                const CppTL::ConstString &name, 
                const Properties &info,
                const ParentSuites &parents )
         : id_( id )
         , name_( name )
         , info_( info )
         , parents_( parents )
d111 5
d118 4
a121 5
      TestId id_;
      CppTL::ConstString name_;
      Properties info_;
      ParentSuites parents_;
      ParentSuites children_;
a122 38

   typedef std::set<TestId> Tests;
   typedef std::deque<TestResult> Results;
   typedef std::vector<unsigned int> TestResultIndexes;
   typedef std::map<TestId,InternalTestInfo> TestInfos;

   TestId nextTestId();

   void outputFailures();

   const InternalTestInfo &getTestInfo( TestId id ) const;
   InternalTestInfo &getTestInfo( TestId id );

   void declareTestOrSuite( TestId id, 
                            const CppTL::ConstString &name, 
                            const Properties &data );

   CppTL::ConstString getTestPath( TestId test, unsigned int maxParent = (unsigned int)-1 ) const;

   void reportFailure( const TestResult &testResult,
                       const Properties &failure, 
                       bool isAssertion );

   TestRunner &runner_;
   /// Information associated to each test/suite at declaration time
   TestInfos testInfos_;
   /// TestId of all test cases.
   Tests tests_;
   /// TestId of all suites.
   Tests suites_;
   /// Stack of parent suite for 'current' declared test.
   ParentSuites declaratorParentSuites_;
   /// List of test to run.
   Tests testsToRun_;
   Results results_;
   TestResultIndexes failures_;
   TestResultIndexes successes_;
   TestId nextTestId_;
d126 1
a126 1
} // namespace OpenTest
a127 2

#endif // OPENTEST_TEXTTESTDRIVER_H_INCLUDED
@


1.9
log
@* added TestInfoExplorer interface to inspect declared tests.
@
text
@a9 1
# include <iostream> // for progress
a10 1
# include <stack>
a259 613

// Inline implementation of TextTestDriver
// //////////////////////////////////////////////////////////////////

TestPlanEntryPtrEnum 
TestDriverTestPlan::entries() const
{
   return CppTL::Enum::anyContainer( entries_ );

}


void 
TestDriverTestPlan::add( const TestPlanEntryPtr &entry )
{
   entries_.push_back( entry );
}



// Inline implementation of TestResult
// //////////////////////////////////////////////////////////////////

inline
TestResult::TestResult( TestPlanEntryId id, 
                        TestId test )
   : id_( id )
   , test_( test )
{
}


inline TestPlanEntryId 
TestResult::id() const
{
   return id_;
}


inline TestId 
TestResult::test() const
{
   return test_;
}


inline const Properties &
TestResult::result() const
{
   return result_;
}


inline Properties &
TestResult::result()
{
   return result_;
}



// Inline implementation of TestDriverTestPlanEntry
// //////////////////////////////////////////////////////////////////

inline 
TestDriverTestPlanEntry::TestDriverTestPlanEntry( TestPlanEntryId id,
                                                  TestId test,
                                                  const Properties &configuration )
   : id_( id )
   , test_( test )
   , configuration_( configuration )
{
}


TestPlanEntryId 
TestDriverTestPlanEntry::id() const
{
   return id_;
}


/// Test to run
TestId 
TestDriverTestPlanEntry::test() const
{
   return test_;
}


/// Used to pass configuration data to the test runner or the test itself
const Properties &
TestDriverTestPlanEntry::configuration() const
{
   return configuration_;
}



// Inline implementation of TextTestDriver
// //////////////////////////////////////////////////////////////////

inline 
TextTestDriver::TextTestDriver( TestRunner &runner )
   : runner_( runner )
   , nextTestId_( 0 )
{
   runner_.declareTests( *this );
   std::cout << "Declared suites: " << suites_.size() << "\n"
             << "Declared tests: " << tests_.size() << std::endl;
}


inline bool 
TextTestDriver::run()
{
   if ( testsToRun_.empty() )
      testsToRun_ = tests_;

   TestDriverTestPlan plan;
   Tests::const_iterator itTest = testsToRun_.begin();
   unsigned int entryId = 0;
   for ( ; itTest != testsToRun_.end(); ++itTest )
      plan.add( TestPlanEntryPtr( new TestDriverTestPlanEntry( 
                                         ++entryId,
                                         *itTest, 
                                         Properties() ) ) );

   runner_.runTests( plan, *this, Properties() );

   outputFailures();

   return failures_.empty();
}


inline TestId 
TextTestDriver::beginSuite( const CppTL::ConstString &name,
                            const Properties &data )
{
   TestId id = nextTestId();
   declareTestOrSuite( id, name, data );
   declaratorParentSuites_.push_back( id );
   suites_.insert( id );
   return id;
}


inline TestId 
TextTestDriver::addTest( const CppTL::ConstString &name,
                         const Properties &data )
{
   TestId id = nextTestId();
   declareTestOrSuite( id, name, data );
   tests_.insert( id );
   return id;
}


inline void 
TextTestDriver::endSuite()
{
   declaratorParentSuites_.pop_back();
}


void
TextTestDriver::declareTestOrSuite( TestId id, 
                                    const CppTL::ConstString &name, 
                                    const Properties &data )
{
   InternalTestInfo info( id, name, data, declaratorParentSuites_ );
   testInfos_.insert( TestInfos::value_type( id, info ) );
   if ( declaratorParentSuites_.size() > 0 )
   {
      TestId parentId = declaratorParentSuites_.back();
      getTestInfo(parentId).children_.push_back( id );
   }
}


inline TestId 
TextTestDriver::nextTestId()
{
   return ++nextTestId_;
}


inline void 
TextTestDriver::startTestRun()
{
   results_.clear();
   successes_.clear();
   failures_.clear();
}


inline void 
TextTestDriver::startTest( const TestPlanEntry &testEntry )
{
   TestResult result( testEntry.id(), 
                      testEntry.test() );
   // should add descriptive test data first
   result.result().mergeReplacingExisting( testEntry.configuration() );
   results_.push_back( result );

   const unsigned int maxParent = 1;
   std::cout  <<  "Testing '" << getTestPath( testEntry.test(), 
                                              maxParent ) << "' : ";
   std::cout.flush();
}


inline void 
TextTestDriver::mergeInTestResult( const TestPlanEntry &testEntry,
                                   const Properties &result )
{
   results_.back().result()["result"].asProperties().mergeReplacingExisting( result );
}


inline void 
TextTestDriver::mergeInTestResult( const TestPlanEntry &testEntry,
                                   const PropertyPath &path,
                                   const Value &value )
{
   results_.back().result()["result"][path] = value;
}


inline void 
TextTestDriver::appendToTestResult( const TestPlanEntry &testEntry,
                                    const PropertyPath &path,
                                    const Value &value )
{
   results_.back().result()["result"][path].append( value );
}


inline void 
TextTestDriver::endTest( const TestPlanEntry &testEntry )
{
   const Properties &result = results_.back().result();
   PropertiesAccessor status = result.accessor()["result"]["status"];
   bool succeeded = status.getValue( "success", false ).asBool();
   CppTL::ConstString statusInfo = succeeded ? "OK" : "FAIL";
   if ( succeeded )
      successes_.push_back( results_.size() - 1 );
   else
      failures_.push_back( results_.size() - 1 );

   CppTL::ConstString resultType = status.getValue( "type", "" ).asString();
   if ( !resultType.empty() )
      statusInfo += " (" + resultType + ")";

   std::cout << statusInfo << std::endl;
   std::cout.flush();
//   std::cout << result.toString() << std::endl;
}


inline void 
TextTestDriver::endTestRun()
{
}


inline bool 
TextTestDriver::shouldStopTestRun()
{
   return false;
}


inline const TextTestDriver::InternalTestInfo &
TextTestDriver::getTestInfo( TestId test ) const
{
   TestInfos::const_iterator it = testInfos_.find( test );
   if ( it == testInfos_.end() )
      throw std::invalid_argument( "TextTestDriver::getTestInfo() : bad TestId." );
   return it->second;
}


inline TextTestDriver::InternalTestInfo &
TextTestDriver::getTestInfo( TestId test )
{
   TestInfos::iterator it = testInfos_.find( test );
   if ( it == testInfos_.end() )
      throw std::invalid_argument( "TextTestDriver::getTestInfo() : bad TestId." );
   return it->second;
}


inline void 
TextTestDriver::outputFailures()
{
   if ( failures_.empty() )
   {
      std::cout  <<  "All "  <<  testsToRun_.size()  <<  " tests passed..."   
                 <<  std::endl;
      return;
   }

   TestResultIndexes::const_iterator failuresIt = failures_.begin();
   for ( ; failuresIt != failures_.end(); ++failuresIt )
   {
      // @@todo update to new result properties structure
      const TestResult &testResult = results_.at( *failuresIt );
      PropertiesAccessor info = testResult.result().accessor();
      Properties::ValueEnum enumFaults = info["result/faults"].listValues();
      while ( enumFaults.hasNext() )
      {
         // @@todo check is properties => schema check ?
         Value fault = enumFaults.next(); 
         reportFailure( testResult, fault.asProperties(), false );
      }
      Properties::ValueEnum enumAssertions = info["result/assertions"].listValues();
      while ( enumAssertions.hasNext() )
      {
         // @@todo check is properties => schema check ?
         Value assertion = enumAssertions.next();
         reportFailure( testResult, assertion.asProperties(), true );
      }
/*
      PropertiesAccessor locationInfo = info["result"]["status"]["location"];
      if ( locationInfo.isValid() )
      {
         std::cout << locationInfo.getValue("file").asString() << "(" 
                   << locationInfo.getValue("line").asInt() << ") : ";
      }
      else
      {
         std::cout << "Unknown failure location : ";
      }

      std::cout << getTestPath( testResult.test() ) << std::endl;

      CppTL::ConstString failureType = info["result"]["status"].getValue("type","").asString();
      if ( !failureType.empty() )
         std::cout << "Failure type : " << failureType << std::endl;

      CppTL::ConstString message = info["result"]["status"].getValue("message","").asString();
      if ( !message.empty() )
         std::cout << message << std::endl;
         */

      std::cout  <<  "Failures: "  << failures_.size()  <<  ", ";
      std::cout  <<  "Tested: "  <<  testsToRun_.size()  <<  std::endl;
   }
}


inline void 
TextTestDriver::reportFailure( const TestResult &testResult,
                               const Properties &failure, 
                               bool isAssertion )
{
   if ( failure.has( "location") )
   {
      if ( failure.has("location/file") )
      {
         std::cout << failure["location/file"].asString() << "(" 
                   << failure["location/line"].asInt() << ") ";
      }
      if ( failure.has("location/function") )
         std::cout << "{" << failure["location/function"].asString() << "} ";
      std::cout << " : ";
   }

   std::cout << getTestPath( testResult.test() ) << std::endl;

   CppTL::ConstString failureType = failure.getValue( "failure_type",
                                               isAssertion ? "assertion" 
                                                           : "fault" ).asString();
   std::cout << "Failure type : " << failureType << std::endl;
   Properties::ValueEnum enumMessages = failure.accessor()["messages"].listValues();
   if ( enumMessages.hasNext() )
      std::cout << "Messages:\n";
   while ( enumMessages.hasNext() )
   { // @@todo check type
      CppTL::ConstString message = enumMessages.next().asString();
      std::cout << message << std::endl;
   }

   Properties::ValueEnum enumLogs = failure.accessor()["logs"].listValues();
   if ( enumLogs.hasNext() )
      std::cout << "Log:\n";
   while ( enumLogs.hasNext() )
   { // @@todo check type
      CppTL::ConstString log = enumLogs.next().asString();
      std::cout << log << std::endl;
   }

   std::cout << "Failure tree:" << failure.toString() << std::endl;
}

inline CppTL::ConstString 
TextTestDriver::getTestPath( TestId test, unsigned int maxParent ) const
{
   CppTL::ConstString path;
   const InternalTestInfo &info = getTestInfo( test );
   path = "/" + info.name_;
   if ( info.parents_.empty() )
      return path;

   bool isPartialPath = maxParent < info.parents_.size();

   for ( unsigned int index = info.parents_.size()-1; 
         index != -1  &&  maxParent-- >0; 
         --index )
   {
      const InternalTestInfo &parentInfo = getTestInfo( info.parents_[index] );
      path = "/" + parentInfo.name_ + path;
   }

   if ( isPartialPath )
      path = ".." + path;
   return path;
}

// Implementation of TestInfoExplorer
// //////////////////////////////////////////////////////////////////

namespace Impl {

   struct IsTestSuiteOrTestCaseFilter
   {
      IsTestSuiteOrTestCaseFilter( bool keepSuite )
         : keepSuite_( keepSuite )
      {
      }

      bool operator()( const TestInfo &info ) const
      {
         return info.isTestSuite() == keepSuite_;
      }

      bool keepSuite_;
   };

   struct TestId2TestInfoAdapator
   {
      typedef TestInfo result_type;
      TestId2TestInfoAdapator( const TestInfoHolder &holder )
         : holder_( holder )
      {
      }

      TestInfo operator()( TestId id ) const
      {
         return TestInfo( holder_, id );
      }

      const TestInfoHolder &holder_;
   };

} // namespace Impl


inline TestInfoEnumerator 
TextTestDriver::getAllTestCases() const
{
   return CppTL::Enum::anyTransform( CppTL::Enum::container( tests_, CppTL::Type<TestId>() ),
                                     Impl::TestId2TestInfoAdapator( *this ) );
}


inline TestInfoEnumerator 
TextTestDriver::getAllTestSuites() const
{
   return CppTL::Enum::anyTransform( CppTL::Enum::container( suites_, CppTL::Type<TestId>() ),
                                     Impl::TestId2TestInfoAdapator( *this ) );
}


inline TestInfo 
TextTestDriver::getRootTestSuite() const
{
   TestId id;
   if ( !tests_.empty() )
      id = *(tests_.begin());
   else if ( !suites_.empty() )
      id = *(suites_.begin());
   else
      throw std::logic_error( "TextTestDriver::getRootTestSuite(): no suite defined." );

   while ( !getTestInfo(id).parents_.empty() )
      id = *(getTestInfo(id).parents_.begin());
   return TestInfo( *this, id );
}



// Implementation of TestInfoHolder
// //////////////////////////////////////////////////////////////////

inline const String &
TextTestDriver::getTestName( TestId id ) const
{
   return getTestInfo(id).name_;
}


inline PropertiesAccessor
TextTestDriver::getTestDescription( TestId id ) const
{
   return getTestInfo(id).info_.accessor()["description"];
}


inline PropertiesAccessor
TextTestDriver::getTestInput( TestId id ) const
{
   return getTestInfo(id).info_.accessor()["input"];
}


inline bool 
TextTestDriver::isTestSuite( TestId id ) const
{
   return suites_.count(id) > 0;
}


inline TestInfoEnumerator 
TextTestDriver::getTestChildren( TestId id ) const
{
   return CppTL::Enum::anyTransform( CppTL::Enum::container( getTestInfo(id).children_ ),
                                     Impl::TestId2TestInfoAdapator( *this ) );
}


inline TestInfoEnumerator 
TextTestDriver::getTestParents( TestId id ) const
{
   return CppTL::Enum::anyTransform( CppTL::Enum::container( getTestInfo(id).parents_ ),
                                     Impl::TestId2TestInfoAdapator( *this ) );
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class TestInfo
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

inline
TestInfo::TestInfo( const TestInfoHolder &holder,
                    TestId id )
   : id_( id )
   , holder_( holder )
{
}

inline const String &
TestInfo::getName() const
{
   return holder_.getTestName( id_ );
}

inline PropertiesAccessor
TestInfo::getDescription() const
{
   return holder_.getTestDescription( id_ );
}

inline bool 
TestInfo::isTestSuite() const
{
   return holder_.isTestSuite( id_ );
}

inline bool 
TestInfo::isTestCase() const
{
   return !isTestSuite();
}


inline TestInfoEnumerator 
TestInfo::getParents() const
{
   return holder_.getTestParents( id_ );
}


inline PropertiesAccessor
TestInfo::getInput() const
{
   return holder_.getTestInput( id_ );
}

inline TestInfoEnumerator 
TestInfo::getChildren() const
{
   return holder_.getTestChildren( id_ );
}

inline TestInfoEnumerator 
TestInfo::getChildTestSuites() const
{
   return CppTL::Enum::anyFilter( getChildren(), 
                                  Impl::IsTestSuiteOrTestCaseFilter(true) );
}

inline TestInfoEnumerator 
TestInfo::getChildTestCases() const
{
   return CppTL::Enum::anyFilter( getChildren(), 
                                  Impl::IsTestSuiteOrTestCaseFilter(false) );
}

a262 1

@


1.8
log
@* use CppTL::ConstString instead of std::string for thread-safety
@
text
@d7 1
d71 64
d139 2
d149 6
a154 1
private: // overriden from TestDeclarator
d189 8
d202 1
a202 1
   struct TestInfo
d204 1
a204 1
      TestInfo( TestId id, 
d219 1
a222 1
   typedef std::map<TestId,TestId> Hierarchy;   // suite <-> tests
d225 1
a225 1
   typedef std::map<TestId,TestInfo> TestInfos;
d231 2
a232 1
   const TestInfo &getTestInfo( TestId id ) const;
a250 2
   /// Parent/Child association to describe the hierarchy
   Hierarchy hierarchy_;
d433 1
a433 1
   TestInfo info( id, name, data, declaratorParentSuites_ );
d436 4
a439 1
      hierarchy_.insert( Hierarchy::value_type( declaratorParentSuites_.back(), id ) );
d536 1
a536 1
inline const TextTestDriver::TestInfo &
d546 10
d663 1
a663 1
   const TestInfo &info = getTestInfo( test );
d674 1
a674 1
      const TestInfo &parentInfo = getTestInfo( info.parents_[index] );
d683 192
@


1.7
log
@* made ParentSuites public (failed to compile with suncc)
@
text
@d78 1
a78 1
//   void selectTest( const std::string &name );
d83 1
a83 1
   TestId beginSuite( const std::string &name,
d86 1
a86 1
   TestId addTest( const std::string &name,
d125 1
a125 1
                const std::string &name, 
d136 1
a136 1
      std::string name_;
d154 1
a154 1
                            const std::string &name, 
d157 1
a157 1
   std::string getTestPath( TestId test, unsigned int maxParent = (unsigned int)-1 ) const;
d320 1
a320 1
TextTestDriver::beginSuite( const std::string &name,
d332 1
a332 1
TextTestDriver::addTest( const std::string &name,
d351 1
a351 1
                                    const std::string &name, 
d425 1
a425 1
   std::string statusInfo = succeeded ? "OK" : "FAIL";
d431 1
a431 1
   std::string resultType = status.getValue( "type", "" ).asString();
d508 1
a508 1
      std::string failureType = info["result"]["status"].getValue("type","").asString();
d512 1
a512 1
      std::string message = info["result"]["status"].getValue("message","").asString();
d542 1
a542 1
   std::string failureType = failure.getValue( "failure_type",
d551 1
a551 1
      std::string message = enumMessages.next().asString();
d560 1
a560 1
      std::string log = enumLogs.next().asString();
d567 1
a567 1
inline std::string 
d570 1
a570 1
   std::string path;
@


1.6
log
@* removed warning about negative unsigned
@
text
@d117 3
a120 1
   typedef std::deque<TestId> ParentSuites;
@


1.5
log
@* added reporting of error and fault
@
text
@d155 1
a155 1
   std::string getTestPath( TestId test, unsigned int maxParent = -1 ) const;
@


1.4
log
@* TestContext: no longer rely on exception to retrieve failure
* TestContext: removed TestListener support since everything is handled by TestInfo
* TestFailureGuard: modified to report fault using TestInfo instead of exception
* TestListener, TestResult, TestRunResult: removed, replaced by TestInfo
* TextTestDriver: fixed bug in result merging (not prefixed with "/result"). Still need work to handle assertion and fault reporting.
@
text
@d157 4
d478 15
d513 1
d521 44
@


1.3
log
@* modified TestRunner/TestDriver protocol to allow incremental result properties update.
@
text
@d391 1
a391 1
   results_.back().result().mergeReplacingExisting( result );
d400 1
a400 1
   results_.back().result()[path] = value;
d409 1
a409 1
   results_.back().result()[path].append( value );
d431 1
a467 1

d471 1
@


1.2
log
@* removed the addSuite() method during test declaration (make implementation of test driver more complex).
@
text
@a32 2
   void addTestResultInfo( const Properties &result );

d96 10
a105 2
   void addTestInfo( const TestPlanEntry &testEntry,
                     const Properties &data );
a208 7
inline void 
TestResult::addTestResultInfo( const Properties &result )
{
   result_.mergeReplacingExisting( result );
}


d377 1
a377 1
   result.addTestResultInfo( testEntry.configuration() );
d388 20
a407 2
TextTestDriver::addTestInfo( const TestPlanEntry &testEntry,
                             const Properties &data )
d409 1
a409 1
   results_.back().addTestResultInfo( data );
@


1.1
log
@* rough implementation of a simple TextTestDriver.
@
text
@a90 2
   void addSuite( TestId suite );

d112 2
d116 4
a119 1
      TestInfo( TestId id, const std::string &name, const Properties &info )
d123 1
d130 1
a134 1
   typedef std::stack<TestId> DeclarationSuites;
d145 6
d152 1
d154 1
d156 1
d158 1
d160 3
a162 1
   DeclarationSuites declarationSuites_;
d319 2
a320 1
   declarationSuites_.push( id );
a321 2
   TestInfo info( id, name, data );
   testInfos_.insert( TestInfos::value_type( id, info ) );
d331 1
a331 1
   hierarchy_.insert( Hierarchy::value_type( declarationSuites_.top(), id ) );
a332 2
   TestInfo info( id, name, data );
   testInfos_.insert( TestInfos::value_type( id, info ) );
d338 1
a338 1
TextTestDriver::addSuite( TestId suite )
d340 1
a340 1
   hierarchy_.insert( Hierarchy::value_type( declarationSuites_.top(), suite ) );
d344 4
a347 2
inline void 
TextTestDriver::endSuite()
d349 4
a352 1
   declarationSuites_.pop();
d381 3
a383 1
   std::cout  <<  "Testing '" << getTestInfo( testEntry.test() ).name_ << "' : ";
d467 1
a467 1
      std::cout << getTestInfo( testResult.test() ).name_ << std::endl;
d482 25
@

