head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.14;

1.14
date	2006.03.10.21.28.38;	author blep;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.06.21.07.30;	author blep;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.06.08.40.49;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.11.17.16.08;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.09.22.59.09;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.08.20.25.49;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.07.22.43.07;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.06.07.31.42;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.04.08.12.32;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.01.08.19.37;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.30.21.49.25;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.26.19.41.15;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.24.19.41.50;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.24.08.23.49;	author blep;	state Exp;
branches;
next	;


desc
@@


1.15
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#ifndef OPENTEST_SERIALIZER_H_INCLUDED
# define OPENTEST_SERIALIZER_H_INCLUDED

# include <opentest/forwards.h>
# include <json/value.h>
# include <cpptl/conststring.h>
# include <map>
# include <deque>
# include <vector>


namespace OpenTest {

   typedef CppTL::LargestInt LargestInt;
   typedef CppTL::LargestUnsignedInt LargestUnsignedInt;

class OPENTEST_API Packets
{
   friend class PacketsTest;
public:
   typedef unsigned char Byte;
   typedef unsigned int Pos;

   Packets( Pos defaultPacketSize = 16384 );
   virtual ~Packets();

   void beginWriteMessage();
   void endWriteMessage();
   //void beginReadMessage();
   //void endReadMessage();
   bool hasPendingMessage() const;
   Pos getFirstMessageLength();
   void discardFirstMessage();

   /// Read the specified length of data from packets
   /// @@returns Length of data actually read and written in the buffer.
   Pos read( void *data, Pos length );

   /// Read a single byte
   /// @@returns byte read, ccEndBuffer if no byte available for reading.
   Byte readByte();

   /// Seeks read position backward in current message.
   void unreadLastByte();

   /// Write the specified data in the packets
   void write( const void *buffer, Pos length );

   /// Write the specified byte in the packets
   void writeByte( Byte byte );

private:
   // Binary packet with intrusive double linked list.
   struct Packet
   {
      Packet( Pos size, Packet *previous )
         : begin_( new Byte[size] )
         , endInitialized_( begin_ )
         , end_( begin_ + size )
         , previous_( previous )
         , next_( 0 )
      {
         if ( previous )
         {
            next_ = previous_->next_;
            previous_->next_ = this;
         }
      }

      ~Packet()
      {
         if ( previous_ )
            previous_->next_ = next_;
         if ( next_ )
            next_->previous_ = previous_;
         delete[] begin_;
      }

      Pos length() const
      {
         return end_ - begin_;
      }

      Byte *offset( Pos offsetInByte ) 
      {
         return begin_ + offsetInByte;
      }

      Packet *previous_;
      Packet *next_;
      Byte *begin_;
      Byte *end_;
      Byte *endInitialized_;
   };

   struct PacketPos
   {
      PacketPos( Packet *packet = 0, Pos offsetPos = 0 )
         : packet_( packet )
         , currentData_( packet ? packet->offset(offsetPos) : 0 )
      {
      }

      operator bool() const
      {
         return packet_ != 0;
      }

      bool operator !() const
      {
         return packet_ == 0;
      }

      Pos offset() const
      {
         CPPTL_ASSERT_MESSAGE( packet_ != 0, "No packet to get the offset of." );
         return currentData_ - packet_->begin_;
      }

      Pos availableForWriting() const
      {
         CPPTL_ASSERT_MESSAGE( packet_ != 0, "No packet available" );
         return packet_->end_ - currentData_;
      }

      Pos availableUntilEnd() const
      {
         CPPTL_ASSERT_MESSAGE( packet_ != 0, "No packet available" );
         CPPTL_ASSERT_MESSAGE( endInitialized_ == end_, 
                               "availableUntilEnd() can only be called on full packet" );
         return packet_->end_ - currentData_;
      }

      Pos availableForReading() const
      {
         CPPTL_ASSERT_MESSAGE( packet_ != 0, "No packet available" );
         return packet_->endInitialized_ - currentData_;
      }

      void seekToNextPacketIfAtEnd()
      {
         if ( packet_  &&  currentData_ == packet_->end_  &&  packet_->next_ )
            seekToNextPacket();
      }

      void seekBeforeEndOfPreviousPacket()
      {
         CPPTL_ASSERT_MESSAGE( packet_  &&  packet_->previous_, "No previous packet." );
         packet_ = packet_->previous_;
         currentData_ = packet_->end_ - 1;
      }

      void seekToNextPacket()
      {
         packet_ = packet_->next_;
         currentData_ = packet_->begin_;
      }

      Packet *packet_;
      Byte *currentData_;
   };

   // Describes data for a RemoteMessage
   struct MessagePacket
   {
      PacketPos position_;    // Position where the RemoteMessage can be found
      Pos length_;   // Length of the RemoteMessage in bytes.
   };
   
   void appendPacketIfFull();
   Pos distance( const PacketPos &begin, 
                 const PacketPos &end ) const;
   void write( PacketPos &pos, const Byte *data, Pos length );
   /// Returns the length actually read
   Pos read( PacketPos &pos, Byte *data, Pos length );

   private:
   std::deque<MessagePacket> messages_;
   Packet *packetsHead_;
   PacketPos readPos_;   // Position from where data are read or write for serialization
   PacketPos writePos_;    // Position where data are read/write on transport medium
   Pos defaultPacketSize_;
};



class OPENTEST_API Stream
{
public:
   Stream();
   virtual ~Stream();

   Packets &packets();

   Stream &operator <<( bool value );
   Stream &operator <<( int value );
   Stream &operator <<( unsigned int value );
#ifndef CPPTL_NO_INT64
   Stream &operator <<( LargestInt value );
   Stream &operator <<( LargestUnsignedInt value );
#endif
   Stream &operator <<( double value );
   Stream &operator <<( const String &str );
   Stream &operator <<( const Json::Value &properties );

   Stream &operator >>( bool &value );
   Stream &operator >>( int &value );
   Stream &operator >>( unsigned int &value );
#ifndef CPPTL_NO_INT64
   Stream &operator >>( LargestInt &value );
   Stream &operator >>( LargestUnsignedInt &value );
#endif
   Stream &operator >>( double &value );
   Stream &operator >>( String &str );
   Stream &operator >>( Json::Value &properties );

   bool inError() const;
   Stream &setError( const char *errorMessage );

private:
   typedef unsigned char Byte;

   void doSerializeInteger( Byte kind, 
                            LargestUnsignedInt value );
   void doUnserializeInteger( LargestUnsignedInt &value );
   void saveDictionnaryEntry( const String &str );
   void readDictionnaryEntry( Byte control,
                              String &str );
   void readString( String &str );

   Byte readNextByte();
   void ungetLastByte();
   void read( void *buffer, unsigned int length );
   void write( const void *buffer, unsigned int length );
   void write( Byte byte );
   static bool isNamedPropertyControl( Byte control );
   void unserializeArrayValue( Value &value );
   void unserializeObjectValue( Byte control,
                                Value &value );
   void serializeArrayValue( const Value &value );
   void serializeObjectValue( const Value &value );

private:
   struct BufferData
   {
      unsigned int length_;
      unsigned char *data_;
   };

   Packets packets_;
   typedef std::map<String,unsigned int> IndexesByString;
   typedef std::deque<String> StringsByIndex;
   IndexesByString indexesByString_;
   StringsByIndex stringsByIndex_;
   char stringBuffer_[4096];
   const char *error_;
};


template<class SequenceType>
Stream &serializeSTLSequence( Stream &stream, const SequenceType &sequence )
{
   CPPTL_TYPENAME SequenceType::const_iterator it = sequence.begin();
   CPPTL_TYPENAME SequenceType::const_iterator itEnd = sequence.end();
   unsigned int size = itEnd - it;
   stream << size;
   for ( ; it != itEnd; ++it )
      stream << *it;
   return stream;
}

template<class SequenceType>
Stream &unserializeSTLSequence( Stream &stream, SequenceType &sequence )
{
   unsigned int size;
   stream >> size;
   sequence.resize( size );
   CPPTL_TYPENAME SequenceType::iterator it = sequence.begin();
   CPPTL_TYPENAME SequenceType::iterator itEnd = sequence.end();
   for ( ; it != itEnd; ++it )
      stream >> *it;
   return stream;
}

template<class SequenceType>
Stream &serializeSTLMap( Stream &stream, const SequenceType &sequence )
{
   CPPTL_TYPENAME SequenceType::const_iterator it = sequence.begin();
   CPPTL_TYPENAME SequenceType::const_iterator itEnd = sequence.end();
   unsigned int size( sequence.size() );
   stream << size;
   for ( ; it != itEnd; ++it )
      stream << it->first << it->second;
   return stream;
}

template<class SequenceType, class KeyType, class MappedType>
Stream &unserializeSTLMap( Stream &stream, 
                           SequenceType &sequence, 
                           KeyType &key,
                           CppTL::Type<MappedType> )
{
   unsigned int size;
   stream >> size;
   CPPTL_TYPENAME SequenceType::iterator itWhere = sequence.begin();
   MappedType value;
   typedef CPPTL_TYPENAME SequenceType::value_type ValueType;
   while ( size-- > 0 )
   {
      stream >> key >> value;
      itWhere = sequence.insert( itWhere, ValueType(key,value ) );
   }
   return stream;
}


} // namespace OpenTest

#endif // OPENTEST_SERIALIZER_H_INCLUDED

@


1.14
log
@* added unit test for Packets::discardFirstMessage() and fixed bug in Packets.
@
text
@@


1.13
log
@* fixed compilation issue with msvc6
@
text
@d126 8
@


1.12
log
@* dead-code removal, obsolescence annotiation
@
text
@d289 5
a293 2
template<class SequenceType, class KeyType>
Stream &unserializeSTLMap( Stream &stream, SequenceType &sequence, KeyType &key )
d298 1
a298 1
   CPPTL_TYPENAME SequenceType::mapped_type value;
@


1.11
log
@* rough sketch of a working OpenTest driver with CppUT adaptor for TestRunner.
@
text
@d17 1
a17 1
class Packets
d179 1
a179 1
class Stream
@


1.10
log
@- removed infinite recursion in Serializer if there was no int64.
@
text
@d277 28
@


1.9
log
@* replaced include/opentest/properties.h with include/json/value.h
* replaced all occurrences of OpenTest::Value and OpenTest::Properties with Json::Value.
@
text
@d191 2
a192 2
   Stream &operator <<( CppTL::int64_t value );
   Stream &operator <<( CppTL::uint64_t value );
@


1.8
log
@- replaced usage of OpenTest::Properties with Json::Value.
  Json::Value provides a simpler interface and a standard *simple* serialization
  format.
- jsoncpp has been inlined in CppTL to make deploy easier and remove
  an external dependency.
@
text
@d5 2
a6 1
# include <opentest/properties.h>
d196 1
a196 1
   Stream &operator <<( const Properties &properties );
d207 1
a207 1
   Stream &operator >>( Properties &properties );
@


1.7
log
@* fixed compilation without RTTI
* revised stringize implementation to allow an additional customization point by overloading toString().
* added test and corrected bug in serialization/packets implementation.
@
text
@d7 1
a195 1
   Stream &operator <<( const Value &value );
a206 1
   Stream &operator >>( Value &value );
d228 5
@


1.6
log
@* Started adding unit tests for Packets.
@
text
@d12 2
a13 8
#ifndef CPPTL_NO_INT64
   typedef CppTL::int64_t LargestInt;
   typedef CppTL::uint64_t LargestUnsignedInt;
#else
   typedef int LargestInt;
   typedef unsigned int LargestUnsignedInt;
#endif

d17 1
d25 4
a28 7
// for transport communication
   void beginMessage();
   void received( void *data, Pos length );
   // Returns the length actual written at dest
   unsigned int send( void *dest, Pos availableLength );
   void endSerializeMessage();
   void endExternalMessage();
d33 16
a48 6
// for serialization
   unsigned char serializationReadNextByte();
   void serializationUngetLastByte();
   bool serializationRead( void *buffer, Pos length );
   void serializationWrite( const void *buffer, Pos length );
   void serializationWrite( Byte byte );
d127 1
a127 1
         return packet_->endInitialized_ - packet_->begin_;
d160 1
a160 1
   void appendPacketIfFull( PacketPos &pos );
d170 2
a171 2
   PacketPos serializePos_;   // Position from where data are read or write for serialization
   PacketPos externalPos_;    // Position where data are read/write on transport medium
d213 3
a215 1
   void doSerializeInteger( unsigned char kind, 
d219 1
a219 1
   void readDictionnaryEntry( unsigned char control,
d223 1
a223 1
   unsigned char readNextByte();
d227 2
a228 2
   void write( unsigned char byte );
   static bool isNamedPropertyControl( unsigned char control );
@


1.5
log
@* started adding unit tests for opentest
* added serializer unit test squeleton
* fixed some bug in serializer
* added opentesttest project to VS solution.
@
text
@d27 1
a27 1
   Packets();
@


1.4
log
@* RemoteMessage data are interleaved with Packets.
@
text
@d35 2
a36 1
   void endMessage();
d46 1
a46 1
   void serializationWrite( unsigned char byte );
d59 5
a63 2
         next_ = previous_->next_;
         previous_->next_ = this;
@


1.3
log
@Extracted packet management to handle the dual packet cursor cleanly (cursor for serialization and transport).
@
text
@d36 3
d161 1
a161 1
private:
@


1.2
log
@Fixed serialization of stl sequence.
@
text
@d21 147
d174 1
a174 4
   // Call this to add buffer to be "read". Reset read cursor on the first buffer.
   void addBuffer( unsigned int length, const void *data );

   void startsWriteNewMessage();
d226 1
a226 6
   typedef std::vector<BufferData> Buffers;
   Buffers buffers_;
   Buffers::iterator current_;
   unsigned char *currentData_;
   unsigned char *endData_;
   unsigned int writeBufferSize_;
@


1.1
log
@- serialization layer on top of growing buffer for one way communication.
@
text
@d100 2
a101 2
   typedef CPPTL_TYPENAME SequenceType::const_iterator it = sequence.begin();
   typedef CPPTL_TYPENAME SequenceType::const_iterator itEnd = sequence.end();
d110 1
a110 1
Stream &unserializeSTLSequence( Stream &stream, const SequenceType &sequence )
d115 2
a116 2
   typedef CPPTL_TYPENAME SequenceType::const_iterator it = sequence.begin();
   typedef CPPTL_TYPENAME SequenceType::const_iterator itEnd = sequence.end();
@

