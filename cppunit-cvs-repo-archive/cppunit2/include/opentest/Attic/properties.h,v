head	1.15;
access;
symbols
	CPPUNIT2_TG_AFTER_CONSTSTRING:1.11
	CPPUNIT2_TG_BEFORE_CONSTSTRING:1.10
	TG_AFTER_REMOVING_TESTCONTEXT:1.7
	TG_BEFORE_MOVING_ASSERT_TO_TESTINFO:1.4
	TG_BEFORE_REMOVING_TESTCONTEXT:1.2;
locks; strict;
comment	@ * @;


1.15
date	2005.11.08.20.25.49;	author blep;	state dead;
branches;
next	1.14;

1.14
date	2005.11.07.22.43.07;	author blep;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.01.20.32.05;	author blep;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.24.19.45.49;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.27.10.15.57;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.23.21.40.13;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.21.22.26.32;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.20.16.17.33;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.20.15.06.59;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.20.12.12.01;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.19.22.57.57;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.19.19.31.38;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.18.09.20.34;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.15.08.45.24;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.15.08.33.30;	author blep;	state Exp;
branches;
next	;


desc
@@


1.15
log
@* replaced include/opentest/properties.h with include/json/value.h
* replaced all occurrences of OpenTest::Value and OpenTest::Properties with Json::Value.
@
text
@#ifndef OPENTEST_PROPERTIES_H_INCLUDED
# define OPENTEST_PROPERTIES_H_INCLUDED

# include <opentest/forwards.h>
# include <json/value.h>
# include <cpptl/conststring.h>

#endif // OPENTEST_PROPERTIES_H_INCLUDED
@


1.14
log
@- replaced usage of OpenTest::Properties with Json::Value.
  Json::Value provides a simpler interface and a standard *simple* serialization
  format.
- jsoncpp has been inlined in CppTL to make deploy easier and remove
  an external dependency.
@
text
@@


1.13
log
@* added more unit tests for serializer
* fixed bugs
* added strict operator == for Value and Properties.
@
text
@d5 1
a6 390
# include <cpptl/enumerator.h>
# include <stdexcept>
# include <deque>
# include <vector>
# include <typeinfo> // for std::bad_cast

namespace OpenTest {

class OPENTEST_API ValueBadCast : public std::bad_cast
{
public: // overriden from std::bad_cast
   const char * what() const throw()
   {
      return "ValueBadCast: "
             "Value can not be converted to the specified type.";
   }
};


/// Value wrapper for basic type.
/// - strong exception guaranty.
/// - copy constructor is thread-safe
/// ? should we provide conversion of numeric type to string ?
class OPENTEST_API Value
{
public:
   enum Type
   {
      vtNone = 0,
      vtBoolean,
      vtSignedInteger,
      vtUnsignedInteger,
      vtReal,
      vtString,
      vtProperties
   };

# ifdef CPPTL_NO_INT64
   typedef int StorageInt;
   typedef unsigned int StorageUInt;
# else
   typedef CppTL::int64_t StorageInt;
   typedef CppTL::uint64_t StorageUInt;
# endif
   
   Value();

   Value( bool value );

   Value( int value );

   Value( unsigned int value );

# ifndef CPPTL_NO_INT64
   Value( CppTL::int64_t value );

   Value( CppTL::uint64_t value );
# endif

   Value( float value );

   Value( double value );

   Value( const char *value );

   Value( const CppTL::ConstString &value );

   Value( const Properties &value );

   Value( const Value &other );

   Value &operator =( const Value &other );

   ~Value();

   void swap( Value &other );

   bool asBool() const;

   int asInt() const;

   unsigned int asUInt() const;

# ifndef CPPTL_NO_INT64
   StorageInt asInt64() const;

   StorageUInt asUInt64() const;
# endif

   double asReal() const;

   CppTL::ConstString asString() const;

   const Properties &asProperties() const;

   Properties &asProperties();

   bool isNone() const;

   bool isBoolean() const;

   bool isInteger() const;

   bool isSignedInteger() const;

   bool isUnsignedInteger() const;

   bool isReal() const;

   bool isString() const;

   bool isProperties() const;

   bool isConvertibleTo( Type type ) const;

   Type type() const;

   /// Delegates to Properties[] if the value is a Properties.
   Value &operator[]( unsigned int index );

   /// Delegates to Properties[] if the value is a Properties.
   Value &operator[]( const PropertyPath &path );

   /// Delegates to Properties[] if the value is a Properties.
   const Value &operator[]( unsigned int index ) const;

   /// Delegates to Properties[] if the value is a Properties.
   const Value &operator[]( const PropertyPath &path ) const;

   /// Delegates to Properties::append if the value is a Properties.
   Properties &append( const Value &value );

   CppTL::ConstString toString() const;

   bool operator ==( const Value &other ) const;
   bool operator !=( const Value &other ) const;

private:

   struct Storage
   {
      Type type_;

      union
      {
         bool boolValue_;
         StorageInt intValue_;
         StorageUInt uintValue_;
         double realValue_;
         char *stringValue_;
         Properties *propertiesValue_;
      };
   };

   void throwBadCast() const;

   Storage guts_;
};


class OPENTEST_API PropertyPath
{
public:
   typedef CppTL::AnyEnumerator<CppTL::ConstString> NamesEnum;

   PropertyPath( const CppTL::ConstString &path,
                 char separator = '/' );

   PropertyPath( const char *path,
                 char separator = '/' );

   NamesEnum names() const;

   PropertyPath &add( const CppTL::ConstString &name );

   PropertyPath &addPath( const PropertyPath &path );

   PropertyPath parent() const;

   const CppTL::ConstString &name() const;

   bool isEmpty() const;

private:
   typedef std::deque<CppTL::ConstString> PropertyNames;

   PropertyPath( const PropertyNames &names );

   void initialize( const char *path, 
                    char separator );

private:
   PropertyNames names_;
};

class OPENTEST_API Property
{
public:
   Property( const CppTL::ConstString &name, 
             const Value &value );

   const CppTL::ConstString &name() const;

   const Value &value() const;

   Value &value();

   bool operator ==( const Property &other ) const;
   bool operator !=( const Property &other ) const;

private:
   CppTL::ConstString name_;
   Value value_;
};


/*
 Properties properties;
 properties["result"]["status"]["general"] = "pass"; // pass, fail, skip
 properties["result/status/general"] = "pass"; // pass, fail, skip
 properties["result"]["status"]["detail"] = "success";
 properties["result"]["duration"] = 163.5;
 properties["log"].append( "log line 1" );
 */
class OPENTEST_API Properties
{
public:
   typedef CppTL::AnyEnumerator<Value> ValueEnum;
   typedef CppTL::AnyEnumerator<Property> PropertyEnum;
   typedef CppTL::AnyEnumerator<CppTL::ConstString> NameEnum;

   Properties();

   Properties( const Property &property );

   Properties( const Properties &other );

   Properties &operator =( const Properties &other );

   ~Properties();

   void swap( Properties &other );

   void clear();

   Properties &set( const Property &property );

   Properties &set( const CppTL::ConstString &name,
                    const Value &value );
   
   Properties &setIfNew( const Property &property );
   
   Properties &setIfNew( const CppTL::ConstString &name,
                         const Value &value );

   Properties &mergeReplacingExisting( const Properties &properties );

   Properties &mergePreservingExisting( const Properties &properties );

   bool has( const PropertyPath &path ) const;

   const Property &getProperty( const PropertyPath &path ) const;

   const Value &getValue( const PropertyPath &path ) const;

   const Value &at( unsigned int index ) const;

   Value getValue( const PropertyPath &path,
                   const Value &defaultValue ) const;

   Value at( unsigned int index,
             const Value &defaultValue ) const;

   const Value &operator[]( unsigned int index ) const;

   const Value &operator[]( const PropertyPath &path ) const;

   Value &operator[]( unsigned int index );

   /// If there no property named 'name' then create it and initialize it to
   /// an empty Properties => allow chaining ["a"]["b"] to create a tree.
   Value &operator[]( const PropertyPath &path );

   Properties &remove( unsigned int index );

   Properties &remove( const PropertyPath &path );

   Properties &append( const Value &value );

   unsigned int listSize() const;

   bool hasList() const;

   PropertiesAccessor accessor() const;

   ValueEnum listValues() const;

   NameEnum names() const;

   PropertyEnum properties() const;

   CppTL::ConstString toString() const;

   bool operator ==( const Properties &other ) const;
   bool operator !=( const Properties &other ) const;

private:
   // Notes: can not use std::map because VC++6 implementation is buggy and cause
   // crash when exposed in DLL.
   typedef std::vector<Property> PropertyList;
   typedef std::deque<Value> IndexedProperties;

   struct NameAdaptor
   {
      typedef CppTL::ConstString result_type;

      CppTL::ConstString operator()( const Property &property ) const
      {
         return property.name();
      }
   };

   PropertyList::iterator find( const CppTL::ConstString &name );

   PropertyList::const_iterator find( const CppTL::ConstString &name ) const;

   PropertyList::const_iterator resolvePath( const PropertyPath &path ) const;

   Properties *tryGetProperties( const PropertyPath &path );

   const Properties *tryGetProperties( const PropertyPath &path ) const;

   Properties &makeProperties( const PropertyPath &path );

   void checkPathNotEmpty( const PropertyPath &path ) const;

   CppTL::ConstString toString( const CppTL::ConstString &prefix ) const;

   PropertyList properties_;
   IndexedProperties indexedProperties_;
};



/// Helper to navigate the property tree in read-only mode and
/// avoid testing if every single node exist.
class OPENTEST_API PropertiesAccessor
{
public:
   PropertiesAccessor( const Properties *properties = 0 );

   PropertiesAccessor operator[]( unsigned int index ) const;

   PropertiesAccessor operator[]( const PropertyPath &path ) const;

   const Properties &properties() const;

   bool isValid() const;

   bool has( const PropertyPath &path ) const;

   const Property &getProperty( const PropertyPath &path ) const;

   /// If the current node is valid then returns the value of the property
   /// named 'name', otherwise returns an empty value.
   Value getValue( const PropertyPath &path ) const;

   Value at( unsigned int index ) const;

   /// If current node is valid and has a property named 'name' returns its
   /// values, otherwise returns the 'defaultValue'.
   Value getValue( const PropertyPath &path,
                   const Value &defaultValue ) const;

   /// If current node is valid and has a indexed value at the specified
   //// index returns its values, otherwise returns the 'defaultValue'.
   Value at( unsigned int index,
             const Value &defaultValue ) const;

   Properties::ValueEnum listValues() const;

   unsigned int listSize() const;

   bool hasList() const;

private:
   const Properties *properties_;
};

} // namespace OpenTest
@


1.12
log
@removed support for 'long double'. Not much support for that type in the standard library => it would raise too much portability issue.
@
text
@d140 3
d213 3
d309 3
@


1.11
log
@* use CppTL::ConstString instead of std::string for thread-safety
@
text
@a68 2
   Value( long double value );

d95 1
a95 1
   long double asReal() const;
d151 1
a151 1
         long double realValue_;
@


1.10
log
@* fixed included for std::bad_cast
* changed implementation (overridding what() instead of calling contructor as it was not portable).
@
text
@d5 1
a8 1
# include <string>
a13 3
/// @@todo For thread-safety, std::string need to be replaced with an implementation
///       that guaranty that the copy constructor is thread-safe.

d73 1
a73 1
   Value( const std::string &value );
d99 1
a99 1
   std::string asString() const;
d140 1
a140 1
   std::string toString() const;
d168 1
a168 1
   typedef CppTL::AnyEnumerator<std::string> NamesEnum;
d170 1
a170 1
   PropertyPath( const std::string &path,
d178 1
a178 1
   PropertyPath &add( const std::string &name );
d184 1
a184 1
   const std::string &name() const;
d189 1
a189 1
   typedef std::deque<std::string> PropertyNames;
d203 1
a203 1
   Property( const std::string &name, 
d206 1
a206 1
   const std::string &name() const;
d213 1
a213 1
   std::string name_;
d231 1
a231 1
   typedef CppTL::AnyEnumerator<std::string> NameEnum;
d249 1
a249 1
   Properties &set( const std::string &name,
d254 1
a254 1
   Properties &setIfNew( const std::string &name,
d303 1
a303 1
   std::string toString() const;
d313 1
a313 1
      typedef std::string result_type;
d315 1
a315 1
      std::string operator()( const Property &property ) const
d321 1
a321 1
   PropertyList::iterator find( const std::string &name );
d323 1
a323 1
   PropertyList::const_iterator find( const std::string &name ) const;
d335 1
a335 1
   std::string toString( const std::string &prefix ) const;
@


1.9
log
@* fixed bug in Properties::hasList()
* added PropertiesAccessor::listValues()
@
text
@d19 2
a20 3
public:
   ValueBadCast()
      : std::bad_cast( "Bad OpenTest::Value cast." )
d22 2
@


1.8
log
@* added support for test descriptive data
@
text
@a219 44
/// Helper to navigate the property tree in read-only mode and
/// avoid testing if every single node exist.
class OPENTEST_API PropertiesAccessor
{
public:
   PropertiesAccessor( const Properties *properties = 0 );

   PropertiesAccessor operator[]( unsigned int index ) const;

   PropertiesAccessor operator[]( const PropertyPath &path ) const;

   const Properties &properties() const;

   bool isValid() const;

   bool has( const PropertyPath &path ) const;

   const Property &getProperty( const PropertyPath &path ) const;

   /// If the current node is valid then returns the value of the property
   /// named 'name', otherwise returns an empty value.
   Value getValue( const PropertyPath &path ) const;

   Value at( unsigned int index ) const;

   /// If current node is valid and has a property named 'name' returns its
   /// values, otherwise returns the 'defaultValue'.
   Value getValue( const PropertyPath &path,
                   const Value &defaultValue ) const;

   /// If current node is valid and has a indexed value at the specified
   //// index returns its values, otherwise returns the 'defaultValue'.
   Value at( unsigned int index,
             const Value &defaultValue ) const;

   unsigned int listSize() const;

   bool hasList() const;

private:
   const Properties *properties_;
};


d223 1
d343 47
@


1.7
log
@* TestContext: no longer rely on exception to retrieve failure
* TestContext: removed TestListener support since everything is handled by TestInfo
* TestFailureGuard: modified to report fault using TestInfo instead of exception
* TestListener, TestResult, TestRunResult: removed, replaced by TestInfo
* TextTestDriver: fixed bug in result merging (not prefixed with "/result"). Still need work to handle assertion and fault reporting.
@
text
@d237 1
a237 1
   const Property &getProperty( const std::string &name ) const;
d241 1
a241 1
   Value getValue( const std::string &name ) const;
d247 1
a247 1
   Value getValue( const std::string &name,
d308 1
a308 1
   const Property &getProperty( const std::string &name ) const;
d310 1
a310 1
   const Value &getValue( const std::string &name ) const;
d370 2
@


1.6
log
@* added getter to PropertyAccessor to retreive the valid Properties.
@
text
@d255 4
@


1.5
log
@* added toString() to Value & Properties.
@
text
@d231 2
@


1.4
log
@* added support for PropertyPath
@
text
@d142 2
d342 2
d372 2
@


1.3
log
@* started implementing assertion support for both checking and aborting assertion
* TestInfo to send incremental update on the test result to the test driver (logging...)
@
text
@d6 1
a6 1
# include <exception>
d8 1
d10 1
a10 1
# include <string.h>
d131 1
a131 1
   Value &operator[]( const std::string &name );
d137 1
a137 1
   const Value &operator[]( const std::string &name ) const;
d165 34
d227 1
a227 1
   PropertiesAccessor operator[]( const std::string &name ) const;
d231 1
a231 1
   bool has( const std::string &name ) const;
d298 1
a298 1
   bool has( const std::string &name ) const;
d306 1
a306 1
   Value getValue( const std::string &name,
d314 1
a314 1
   const Value &operator[]( const std::string &name ) const;
d320 1
a320 1
   Value &operator[]( const std::string &name );
d324 1
a324 1
   Properties &remove( const std::string &name );
d360 7
a366 1
   static std::string getIndexPropertyName( unsigned int index );
a371 865


// Inline implementation of Value
// //////////////////////////////////////////////////////////////////
   
inline 
Value::Value()
{
   guts_.type_ = vtNone;
}


inline 
Value::Value( bool value )
{
   guts_.type_ = vtBoolean;
   guts_.boolValue_ = value;
}


inline 
Value::Value( int value )
{
   guts_.type_ = vtSignedInteger;
   guts_.intValue_ = value;
}


inline 
Value::Value( unsigned int value )
{
   guts_.type_ = vtUnsignedInteger;
   guts_.intValue_ = value;
}

# ifndef CPPTL_NO_INT64
inline 
Value::Value( CppTL::int64_t value )
{
   guts_.type_ = vtSignedInteger;
   guts_.intValue_ = value;
}


inline 
Value::Value( CppTL::uint64_t value )
{
   guts_.type_ = vtUnsignedInteger;
   guts_.intValue_ = value;
}
# endif


inline 
Value::Value( float value )
{
   guts_.type_ = vtReal;
   guts_.realValue_ = value;
}


inline 
Value::Value( double value )
{
   guts_.type_ = vtReal;
   guts_.realValue_ = value;
}


inline 
Value::Value( long double value )
{
   guts_.type_ = vtReal;
   guts_.realValue_ = value;
}


inline 
Value::Value( const char *value )
{
   guts_.type_ = vtString;
   const unsigned int length = strlen(value) + 1;
   char *buffer = new char[ length ];
   memcpy( buffer, value, length );
   guts_.stringValue_ = buffer;
}


inline 
Value::Value( const std::string &value )
{
   guts_.type_ = vtString;
   char *buffer = new char[ value.size() + 1 ];
   memcpy( buffer, value.c_str(), value.size() + 1 );
   guts_.stringValue_ = buffer;
}


inline 
Value::Value( const Properties &value )
{
   guts_.type_ = vtProperties;
   guts_.propertiesValue_ = new Properties( value );
}


inline 
Value::Value( const Value &other )
{
   guts_ = other.guts_;
   switch ( guts_.type_ )
   {
   case vtString:
      {
         unsigned int length = ::strlen( other.guts_.stringValue_ ) + 1;
         char *buffer = new char[ length ];
         memcpy( buffer, other.guts_.stringValue_, length );
         guts_.stringValue_ = buffer;
      }
      break;
   case vtProperties:
      guts_.propertiesValue_ = new Properties( *other.guts_.propertiesValue_ );
      break;
   default: // copy already handled by the initial binary copy.
      break;
   }
}


inline Value &
Value::operator =( const Value &other )
{
   Value temp( other );
   swap( temp );
   return *this;
}


inline 
Value::~Value()
{
   switch ( guts_.type_ )
   {
   case vtString:
      delete[] guts_.stringValue_;
      break;
   case vtProperties:
      delete guts_.propertiesValue_;
      break;
   default: // not dynamically allocated
      break;
   }
}


inline void 
Value::swap( Value &other )
{
   Storage temp( guts_ );
   guts_ = other.guts_;
   other.guts_ = temp;
}


inline bool
Value::asBool() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_;
   case vtSignedInteger:
   case vtUnsignedInteger:
      return guts_.intValue_ != 0;
   case vtReal:
      return guts_.realValue_ != 0.0;
   default:
      throwBadCast();
      return 0;      // keep the compiler happy
   }
}

inline int
Value::asInt() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_ ? 1 : 0;
   case vtSignedInteger:
   case vtUnsignedInteger:
      return int(guts_.intValue_);
   case vtReal:
      return int( guts_.realValue_ );
   default:
      throwBadCast();
      return 0;      // keep the compiler happy
   }
}


inline unsigned int
Value::asUInt() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_ ? 1 : 0;
   case vtSignedInteger:
   case vtUnsignedInteger:
      return (unsigned int)(guts_.uintValue_);
   case vtReal:
      return (unsigned int)( guts_.realValue_ );
   default:
      throwBadCast();
      return 0;      // keep the compiler happy
   }
}


# ifndef CPPTL_NO_INT64

inline Value::StorageInt
Value::asInt64() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_ ? 1 : 0;
   case vtSignedInteger:
   case vtUnsignedInteger:
      return guts_.intValue_;
   case vtReal:
      return int( guts_.realValue_ );
   default:
      throwBadCast();
      return 0;      // keep the compiler happy
   }
}


inline Value::StorageUInt
Value::asUInt64() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_ ? 1 : 0;
   case vtSignedInteger:
   case vtUnsignedInteger:
      return guts_.uintValue_;
   case vtReal:
      return int( guts_.realValue_ );
   default:
      throwBadCast();
      return 0;      // keep the compiler happy
   }
}

# endif // ifndef CPPTL_NO_INT64

inline long double 
Value::asReal() const
{
   switch ( type() )
   {
   case vtBoolean:
      return guts_.boolValue_ ? 1.0 : 0.0;
   case vtSignedInteger:
      return (long double)(guts_.intValue_);
   case vtUnsignedInteger:
      return (long double)(guts_.uintValue_);
   case vtReal:
      return guts_.realValue_;
   default:
      throwBadCast();
      return 0.0;      // keep the compiler happy
   }
}

inline std::string 
Value::asString() const
{
   switch ( type() )
   {
   case vtString:
      return guts_.stringValue_;
   default:
      throwBadCast();
      return std::string();      // keep the compiler happy
   }
}


inline const Properties &
Value::asProperties() const
{
   return const_cast<Value *>(this)->asProperties();
}


inline Properties &
Value::asProperties()
{
   switch ( type() )    // ? should we provide conversion of numeric type to string ?
   {
   case vtProperties:
      return *(guts_.propertiesValue_);
   default:
      throwBadCast();
      return *( static_cast<Properties *>(0) );      // keep the compiler happy
   }
}


inline bool 
Value::isNone() const
{
   return type() == vtNone;
}


inline bool 
Value::isBoolean() const
{
   return type() == vtBoolean;
}


inline bool 
Value::isInteger() const
{
   return isSignedInteger()  ||  isUnsignedInteger();
}


inline bool 
Value::isSignedInteger() const
{
   return type() == vtSignedInteger;
}


inline bool 
Value::isUnsignedInteger() const
{
   return type() == vtUnsignedInteger;
}


inline bool 
Value::isReal() const
{
   return type() == vtReal;
}


inline bool 
Value::isString() const
{
   return type() == vtString;
}


inline bool 
Value::isProperties() const
{
   return type() == vtProperties;
}


inline bool 
Value::isConvertibleTo( Type type ) const
{
   switch ( guts_.type_ )
   {
   case vtNone:
      return type == vtNone;
   case vtBoolean:
   case vtSignedInteger:
   case vtUnsignedInteger:
   case vtReal:
      return type == vtBoolean  ||
             type == vtSignedInteger  ||
             type == vtUnsignedInteger  ||
             type == vtReal;
   case vtString:
      return type == vtString;
   case vtProperties:
      return type == vtProperties;
   default: // unreachable
      CPPTL_DEBUG_ASSERT_UNREACHABLE;
      break;
   }
}


inline Value::Type 
Value::type() const
{
   return guts_.type_;
}



inline Value &
Value::operator[]( unsigned int index )
{
   return asProperties()[ index ];
}


inline Value &
Value::operator[]( const std::string &name )
{
   return asProperties()[ name ];
}


inline const Value &
Value::operator[]( unsigned int index ) const
{
   return asProperties()[ index ];
}


inline const Value &
Value::operator[]( const std::string &name ) const
{
   return asProperties()[ name ];
}


inline Properties &
Value::append( const Value &value )
{
   return asProperties().append( value );
}


inline void 
Value::throwBadCast() const
{
   throw ValueBadCast();
}



// Inline implementation of Property
// //////////////////////////////////////////////////////////////////

inline
Property::Property( const std::string &name, 
                    const Value &value )
  : name_( name )
  , value_( value )
{
}


inline const std::string &
Property::name() const
{
   return name_;
}


inline const Value &
Property::value() const
{
   return value_;
}


inline Value &
Property::value()
{
   return value_;
}



// Inline implementation of PropertiesAccessor
// //////////////////////////////////////////////////////////////////

inline
PropertiesAccessor::PropertiesAccessor( const Properties *properties )
   : properties_( properties )
{
}


inline bool 
PropertiesAccessor::isValid() const
{
   return properties_ != 0;
}


inline PropertiesAccessor 
PropertiesAccessor::operator[]( unsigned int index ) const
{
   if ( !properties_  ||  index > properties_->listSize() )
      return PropertiesAccessor();

   const Value &value = (*properties_)[ index ];
   if ( !value.isProperties() )
      throw std::invalid_argument( "PropertiesAccessor[]: not a properties." );
   return PropertiesAccessor( &value.asProperties() );
}


inline PropertiesAccessor 
PropertiesAccessor::operator[]( const std::string &name ) const
{
   if ( !properties_  ||  !properties_->has( name ) )
      return PropertiesAccessor();

   const Value &value = (*properties_)[ name ];
   if ( !value.isProperties() )
      throw std::invalid_argument( "PropertiesAccessor[]: not a properties." );
   return PropertiesAccessor( &value.asProperties() );
}


inline bool 
PropertiesAccessor::has( const std::string &name ) const
{
   return properties_ ? properties_->has( name ) : false;
}


inline const Property &
PropertiesAccessor::getProperty( const std::string &name ) const
{
   if ( !properties_ )
      throw std::invalid_argument( "PropertiesAccessor::getProperty() : null" );
   return properties_->getProperty( name );
}


inline Value 
PropertiesAccessor::getValue( const std::string &name ) const
{
   return properties_ ? properties_->getValue( name ) : Value();
}


inline Value 
PropertiesAccessor::at( unsigned int index ) const
{
   return properties_ ? properties_->at( index ) : Value();
}


inline Value 
PropertiesAccessor::getValue( const std::string &name,
                                   const Value &defaultValue ) const
{
   return properties_ ? properties_->getValue( name, defaultValue ) 
                      : defaultValue;
}


inline Value 
PropertiesAccessor::at( unsigned int index,
                             const Value &defaultValue ) const
{
   return properties_ ? properties_->at( index, defaultValue ) 
                      : defaultValue;
}


// Inline implementation of Properties
// //////////////////////////////////////////////////////////////////

inline 
Properties::Properties()
{
}


inline 
Properties::Properties( const Property &property )
{
   set( property );
}


inline
Properties::Properties( const Properties &other )
   : properties_( other.properties_ )
   , indexedProperties_( other.indexedProperties_ )
{
}


inline Properties &
Properties::operator =( const Properties &other )
{
   Properties temp( other );
   swap( temp );
   return *this;
}


inline
Properties::~Properties()
{
}


inline void 
Properties::swap( Properties &other )
{
   properties_.swap( other.properties_ );
   indexedProperties_.swap( other.indexedProperties_ );
}


inline void 
Properties::clear()
{
   properties_.clear();
   indexedProperties_.clear();
}


inline Properties &
Properties::set( const Property &property )
{
   PropertyList::iterator it = find( property.name() );
   if ( it != properties_.end() )
      *it = property;
   else
      properties_.push_back( property );
   return *this;
}


inline Properties &
Properties::set( const std::string &name,
                 const Value &value )
{
   return set( Property( name, value ) );
}


inline Properties &
Properties::setIfNew( const Property &property )
{
   PropertyList::iterator it = find( property.name() );
   if ( it == properties_.end() )
      properties_.push_back( property );
   return *this;
}


inline Properties &
Properties::setIfNew( const std::string &name,
                      const Value &value )
{
   return setIfNew( Property( name, value ) );
}

inline Properties &
Properties::mergeReplacingExisting( const Properties &properties )
{
   PropertyList::const_iterator it = properties.properties_.begin();
   PropertyList::const_iterator itEnd = properties.properties_.end();
   while ( it != itEnd )
      set( *it++ );
   return *this;
}


inline Properties &
Properties::mergePreservingExisting( const Properties &properties )
{
   PropertyList::const_iterator it = properties.properties_.begin();
   PropertyList::const_iterator itEnd = properties.properties_.end();
   while ( it != itEnd )
      setIfNew( *it++ );
   return *this;
}


inline bool 
Properties::has( const std::string &name ) const
{
   return find( name ) != properties_.end();
}


inline const Property &
Properties::getProperty( const std::string &name ) const
{
   PropertyList::const_iterator it = find( name );
   if ( it == properties_.end() )
      throw std::invalid_argument( "Properties::getProperty(" + name + ")" );
   return *it;
}


inline const Value &
Properties::getValue( const std::string &name ) const
{
   return getProperty( name ).value();
}


inline const Value &
Properties::at( unsigned int index ) const
{
   return indexedProperties_.at( index );
}


inline Value
Properties::getValue( const std::string &name,
                      const Value &defaultValue ) const
{
   PropertyList::const_iterator it = find( name );
   if ( it == properties_.end() )
      return defaultValue;
   return it->value();
}


inline Value
Properties::at( unsigned int index,
                const Value &defaultValue ) const
{
   return index < indexedProperties_.size() ? indexedProperties_.at( index )
                                            : defaultValue;
}


inline const Value &
Properties::operator[]( unsigned int index ) const
{
   return indexedProperties_.at( index );
}


inline const Value &
Properties::operator[]( const std::string &name ) const
{
   return getValue( name );
}


inline Value &
Properties::operator[]( unsigned int index )
{
   return indexedProperties_.at( index );
}


inline Value &
Properties::operator[]( const std::string &name )
{
   PropertyList::iterator it = find( name );
   if ( it == properties_.end() )
   {
      Property property( name, Value( Properties() ) );
      properties_.push_back( property );
      it = properties_.end() - 1;
   }
   return it->value();
}


inline Properties &
Properties::append( const Value &value )
{
   indexedProperties_.push_back( value );
   return *this;
}

inline Properties &
Properties::remove( unsigned int index )
{
   if ( index <= indexedProperties_.size() )
      indexedProperties_.erase( indexedProperties_.begin() + index );
   return *this;
}


inline Properties &
Properties::remove( const std::string &name )
{
   PropertyList::iterator it = find( name );
   if ( it != properties_.end() )
      properties_.erase( it );
   return *this;
}


inline unsigned int 
Properties::listSize() const
{
   return indexedProperties_.size();
}


inline bool 
Properties::hasList() const
{
   return listSize() == 0;
}


inline PropertiesAccessor 
Properties::accessor() const
{
   return PropertiesAccessor( this );
}


inline Properties::ValueEnum 
Properties::listValues() const
{
   return CppTL::Enum::anyContainer( indexedProperties_ );
}


inline Properties::NameEnum 
Properties::names() const
{
   return CppTL::Enum::anyTransform( CppTL::Enum::container( properties_ ),
                                     NameAdaptor() );
}

inline Properties::PropertyEnum 
Properties::properties() const
{
   return CppTL::Enum::anyContainer( properties_ );
}


inline Properties::PropertyList::iterator 
Properties::find( const std::string &name )
{
   PropertyList::iterator it = properties_.begin();
   PropertyList::iterator itEnd = properties_.end();
   for ( ; it != itEnd; ++it )
      if ( it->name() == name )
         return it;
   return itEnd;
}


inline Properties::PropertyList::const_iterator 
Properties::find( const std::string &name ) const
{
   PropertyList::const_iterator it = properties_.begin();
   PropertyList::const_iterator itEnd = properties_.end();
   for ( ; it != itEnd; ++it )
      if ( it->name() == name )
         return it;
   return itEnd;
}


a373 2


@


1.2
log
@* removed conversion loss of data warning
@
text
@d4 1
a4 1
# include <opentest/config.h>
d138 3
d247 2
d764 7
d951 8
@


1.1
log
@* initial implementation of the TestRunner interface
@
text
@d517 1
a517 1
      return guts_.intValue_;
d536 1
a536 1
      return guts_.uintValue_;
d538 1
a538 1
      return int( guts_.realValue_ );
d595 1
a595 1
      return guts_.intValue_;
d597 1
a597 1
      return guts_.uintValue_;
@

