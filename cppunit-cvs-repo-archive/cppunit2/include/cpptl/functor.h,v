head	1.6;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.6
	CPPUNIT2_TG_AFTER_CONSTSTRING:1.2
	CPPUNIT2_TG_BEFORE_CONSTSTRING:1.2;
locks; strict;
comment	@ * @;


1.6
date	2005.11.13.10.12.01;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.04.22.17.54;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.28.20.33.34;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.27.14.38.25;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.26.11.40.58;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.25.20.53.56;	author blep;	state Exp;
branches;
next	;


desc
@@


1.6
log
@- renamed include/cpput/assert.h to include/cpput/assertcommon.h. This avoid clash with include <assert.h> in doxygen documentation
- most Impl namespaces are now hidden from documentation using \cond and \endcond.
@
text
@// This script is generated by the python script functor.py
// Do not edit.
#ifndef CPPTL_FUNCTOR_H_INCLUDED
# define CPPTL_FUNCTOR_H_INCLUDED

# include <cpptl/config.h>

namespace CppTL {

// Partially borrowed from the standard
// See: 
// N1453: http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1453.html
template<class T>
class ReferenceWrapper
{
public:
  explicit ReferenceWrapper( T &t ) : t_( &t )
  {
  }

  operator T&() const
  {
     return *t_;
  }

private:
  T *t_;
};

template<class T>
inline ReferenceWrapper<T> 
ref( T &t )
{
  return ReferenceWrapper<T>( t );
}

template<class T>
inline ReferenceWrapper<const T>
cref( const T& t )
{
  return ReferenceWrapper<const T>( t );
}


/// \cond implementation_detail
namespace Impl {

   class FunctorBase
   {
   public:
      virtual ~FunctorBase()
      {
      }

      virtual FunctorBase *clone() const = 0;
   };

   
   class FunctorBase0 : public FunctorBase
   {
   public:
      virtual void operator()(  ) const = 0;
   };

   
   template< class Functor >
   class GenericFunctor0 : public FunctorBase0
   {
   public:
      typedef GenericFunctor0< Functor > SelfType;

      GenericFunctor0( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()(  ) const
      {
         functor_(  );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object >
   class MemberFunctor0 : public FunctorBase0
   {
   public:
      typedef MemberFunctor0< Holder, Object > SelfType;
      typedef void (Object::*MemberFn)(  );

      MemberFunctor0( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()(  ) const
      {
         Object &object = *holder_;
         (object.*member_)(  );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class BindArg >
   class Bind0
   {
   public:
   typedef void result_type;


      Bind0( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()(  ) const
      {
         functor_( arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return >
   class FunctorBase0R : public FunctorBase
   {
   public:
      virtual Return operator()(  ) const = 0;
   };

   
   template< class Functor, class Return >
   class GenericFunctor0R : public FunctorBase0R< Return >
   {
   public:
      typedef GenericFunctor0R< Functor, Return > SelfType;

      GenericFunctor0R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()(  ) const
      {
         return functor_(  );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return >
   class MemberFunctor0R : public FunctorBase0R< Return >
   {
   public:
      typedef MemberFunctor0R< Holder, Object, Return > SelfType;
      typedef Return (Object::*MemberFn)(  );

      MemberFunctor0R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()(  ) const
      {
         Object &object = *holder_;
         return (object.*member_)(  );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class BindArg >
   class Bind0R
   {
   public:
   typedef Return result_type;


      Bind0R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()(  ) const
      {
         return functor_( arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Arg1 >
   class FunctorBase1 : public FunctorBase
   {
   public:
      virtual void operator()( Arg1 a1 ) const = 0;
   };

   
   template< class Functor, class Arg1 >
   class GenericFunctor1 : public FunctorBase1< Arg1 >
   {
   public:
      typedef GenericFunctor1< Functor, Arg1 > SelfType;

      GenericFunctor1( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()( Arg1 a1 ) const
      {
         functor_( a1 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Arg1 >
   class MemberFunctor1 : public FunctorBase1< Arg1 >
   {
   public:
      typedef MemberFunctor1< Holder, Object, Arg1 > SelfType;
      typedef void (Object::*MemberFn)( Arg1 a1 );

      MemberFunctor1( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()( Arg1 a1 ) const
      {
         Object &object = *holder_;
         (object.*member_)( a1 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Arg1, class BindArg >
   class Bind1
   {
   public:
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;


      Bind1( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1 ) const
      {
         functor_( a1, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return, class Arg1 >
   class FunctorBase1R : public FunctorBase
   {
   public:
      virtual Return operator()( Arg1 a1 ) const = 0;
   };

   
   template< class Functor, class Return, class Arg1 >
   class GenericFunctor1R : public FunctorBase1R< Return, Arg1 >
   {
   public:
      typedef GenericFunctor1R< Functor, Return, Arg1 > SelfType;

      GenericFunctor1R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()( Arg1 a1 ) const
      {
         return functor_( a1 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return, class Arg1 >
   class MemberFunctor1R : public FunctorBase1R< Return, Arg1 >
   {
   public:
      typedef MemberFunctor1R< Holder, Object, Return, Arg1 > SelfType;
      typedef Return (Object::*MemberFn)( Arg1 a1 );

      MemberFunctor1R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()( Arg1 a1 ) const
      {
         Object &object = *holder_;
         return (object.*member_)( a1 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class Arg1, class BindArg >
   class Bind1R
   {
   public:
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;


      Bind1R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1 ) const
      {
         return functor_( a1, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Arg1, class Arg2 >
   class FunctorBase2 : public FunctorBase
   {
   public:
      virtual void operator()( Arg1 a1, Arg2 a2 ) const = 0;
   };

   
   template< class Functor, class Arg1, class Arg2 >
   class GenericFunctor2 : public FunctorBase2< Arg1, Arg2 >
   {
   public:
      typedef GenericFunctor2< Functor, Arg1, Arg2 > SelfType;

      GenericFunctor2( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()( Arg1 a1, Arg2 a2 ) const
      {
         functor_( a1, a2 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Arg1, class Arg2 >
   class MemberFunctor2 : public FunctorBase2< Arg1, Arg2 >
   {
   public:
      typedef MemberFunctor2< Holder, Object, Arg1, Arg2 > SelfType;
      typedef void (Object::*MemberFn)( Arg1 a1, Arg2 a2 );

      MemberFunctor2( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()( Arg1 a1, Arg2 a2 ) const
      {
         Object &object = *holder_;
         (object.*member_)( a1, a2 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Arg1, class Arg2, class BindArg >
   class Bind2
   {
   public:
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;


      Bind2( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2 ) const
      {
         functor_( a1, a2, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return, class Arg1, class Arg2 >
   class FunctorBase2R : public FunctorBase
   {
   public:
      virtual Return operator()( Arg1 a1, Arg2 a2 ) const = 0;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2 >
   class GenericFunctor2R : public FunctorBase2R< Return, Arg1, Arg2 >
   {
   public:
      typedef GenericFunctor2R< Functor, Return, Arg1, Arg2 > SelfType;

      GenericFunctor2R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2 ) const
      {
         return functor_( a1, a2 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return, class Arg1, class Arg2 >
   class MemberFunctor2R : public FunctorBase2R< Return, Arg1, Arg2 >
   {
   public:
      typedef MemberFunctor2R< Holder, Object, Return, Arg1, Arg2 > SelfType;
      typedef Return (Object::*MemberFn)( Arg1 a1, Arg2 a2 );

      MemberFunctor2R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2 ) const
      {
         Object &object = *holder_;
         return (object.*member_)( a1, a2 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class BindArg >
   class Bind2R
   {
   public:
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;


      Bind2R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2 ) const
      {
         return functor_( a1, a2, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Arg1, class Arg2, class Arg3 >
   class FunctorBase3 : public FunctorBase
   {
   public:
      virtual void operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const = 0;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3 >
   class GenericFunctor3 : public FunctorBase3< Arg1, Arg2, Arg3 >
   {
   public:
      typedef GenericFunctor3< Functor, Arg1, Arg2, Arg3 > SelfType;

      GenericFunctor3( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         functor_( a1, a2, a3 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Arg1, class Arg2, class Arg3 >
   class MemberFunctor3 : public FunctorBase3< Arg1, Arg2, Arg3 >
   {
   public:
      typedef MemberFunctor3< Holder, Object, Arg1, Arg2, Arg3 > SelfType;
      typedef void (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3 );

      MemberFunctor3( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         Object &object = *holder_;
         (object.*member_)( a1, a2, a3 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3, class BindArg >
   class Bind3
   {
   public:
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;


      Bind3( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         functor_( a1, a2, a3, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return, class Arg1, class Arg2, class Arg3 >
   class FunctorBase3R : public FunctorBase
   {
   public:
      virtual Return operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const = 0;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3 >
   class GenericFunctor3R : public FunctorBase3R< Return, Arg1, Arg2, Arg3 >
   {
   public:
      typedef GenericFunctor3R< Functor, Return, Arg1, Arg2, Arg3 > SelfType;

      GenericFunctor3R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         return functor_( a1, a2, a3 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3 >
   class MemberFunctor3R : public FunctorBase3R< Return, Arg1, Arg2, Arg3 >
   {
   public:
      typedef MemberFunctor3R< Holder, Object, Return, Arg1, Arg2, Arg3 > SelfType;
      typedef Return (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3 );

      MemberFunctor3R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         Object &object = *holder_;
         return (object.*member_)( a1, a2, a3 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3, class BindArg >
   class Bind3R
   {
   public:
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;


      Bind3R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
      {
         return functor_( a1, a2, a3, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Arg1, class Arg2, class Arg3, class Arg4 >
   class FunctorBase4 : public FunctorBase
   {
   public:
      virtual void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const = 0;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4 >
   class GenericFunctor4 : public FunctorBase4< Arg1, Arg2, Arg3, Arg4 >
   {
   public:
      typedef GenericFunctor4< Functor, Arg1, Arg2, Arg3, Arg4 > SelfType;

      GenericFunctor4( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         functor_( a1, a2, a3, a4 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4 >
   class MemberFunctor4 : public FunctorBase4< Arg1, Arg2, Arg3, Arg4 >
   {
   public:
      typedef MemberFunctor4< Holder, Object, Arg1, Arg2, Arg3, Arg4 > SelfType;
      typedef void (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 );

      MemberFunctor4( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         Object &object = *holder_;
         (object.*member_)( a1, a2, a3, a4 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4, class BindArg >
   class Bind4
   {
   public:
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;


      Bind4( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         functor_( a1, a2, a3, a4, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
   class FunctorBase4R : public FunctorBase
   {
   public:
      virtual Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const = 0;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
   class GenericFunctor4R : public FunctorBase4R< Return, Arg1, Arg2, Arg3, Arg4 >
   {
   public:
      typedef GenericFunctor4R< Functor, Return, Arg1, Arg2, Arg3, Arg4 > SelfType;

      GenericFunctor4R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         return functor_( a1, a2, a3, a4 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
   class MemberFunctor4R : public FunctorBase4R< Return, Arg1, Arg2, Arg3, Arg4 >
   {
   public:
      typedef MemberFunctor4R< Holder, Object, Return, Arg1, Arg2, Arg3, Arg4 > SelfType;
      typedef Return (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 );

      MemberFunctor4R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         Object &object = *holder_;
         return (object.*member_)( a1, a2, a3, a4 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class BindArg >
   class Bind4R
   {
   public:
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;


      Bind4R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
      {
         return functor_( a1, a2, a3, a4, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class FunctorBase5 : public FunctorBase
   {
   public:
      virtual void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const = 0;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class GenericFunctor5 : public FunctorBase5< Arg1, Arg2, Arg3, Arg4, Arg5 >
   {
   public:
      typedef GenericFunctor5< Functor, Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;

      GenericFunctor5( const Functor &functor )
         : functor_( functor )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         functor_( a1, a2, a3, a4, a5 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class MemberFunctor5 : public FunctorBase5< Arg1, Arg2, Arg3, Arg4, Arg5 >
   {
   public:
      typedef MemberFunctor5< Holder, Object, Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;
      typedef void (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 );

      MemberFunctor5( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      void operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         Object &object = *holder_;
         (object.*member_)( a1, a2, a3, a4, a5 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class BindArg >
   class Bind5
   {
   public:
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;
   typedef Arg5 arg5_type;


      Bind5( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         functor_( a1, a2, a3, a4, a5, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
   template< class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class FunctorBase5R : public FunctorBase
   {
   public:
      virtual Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const = 0;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class GenericFunctor5R : public FunctorBase5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >
   {
   public:
      typedef GenericFunctor5R< Functor, Return, Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;

      GenericFunctor5R( const Functor &functor )
         : functor_( functor )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         return functor_( a1, a2, a3, a4, a5 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
   template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
   class MemberFunctor5R : public FunctorBase5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >
   {
   public:
      typedef MemberFunctor5R< Holder, Object, Return, Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;
      typedef Return (Object::*MemberFn)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 );

      MemberFunctor5R( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      Return operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         Object &object = *holder_;
         return (object.*member_)( a1, a2, a3, a4, a5 );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
   template< class Functor, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class BindArg >
   class Bind5R
   {
   public:
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;
   typedef Arg5 arg5_type;


      Bind5R( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
      {
         return functor_( a1, a2, a3, a4, a5, arg_ );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   



} // namespace Impl
/// \endcond


class FunctorCommon
{
public:
   ~FunctorCommon()
   {
      delete impl_;
   }

   bool empty() const
   {
      return impl_ == 0;
   }

   operator bool() const
   {
      return impl_ != 0;   
   }

   bool operator !() const
   {
      return impl_ == 0;
   }

protected:
   FunctorCommon()
      : impl_( 0 )
   {
   }

   FunctorCommon( Impl::FunctorBase *impl )
      : impl_( impl )
   {
   }

   FunctorCommon( const FunctorCommon &other )
      : impl_( other.impl_ ? other.impl_->clone() : 0 )
   {
   }

   void swap( FunctorCommon &other )
   {
      Impl::FunctorBase *temp = impl_;
      impl_ = other.impl_;
      other.impl_ = temp;
   }

   Impl::FunctorBase *impl_;

private:
   void operator =( const FunctorCommon &other );
};


class Functor0 : public FunctorCommon
{
public:
   typedef Functor0 SelfType;
   typedef Impl::FunctorBase0 FunctorImplType;
   typedef void result_type;


   Functor0()
   {
   }

   explicit Functor0( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor0( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()(  ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl(  );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return >
class Functor0R : public FunctorCommon
{
public:
   typedef Functor0R< Return > SelfType;
   typedef Impl::FunctorBase0R< Return > FunctorImplType;
   typedef Return result_type;


   Functor0R()
   {
   }

   explicit Functor0R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor0R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()(  ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl(  );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Arg1 >
class Functor1 : public FunctorCommon
{
public:
   typedef Functor1< Arg1 > SelfType;
   typedef Impl::FunctorBase1< Arg1 > FunctorImplType;
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;


   Functor1()
   {
   }

   explicit Functor1( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor1( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl( a1 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return, class Arg1 >
class Functor1R : public FunctorCommon
{
public:
   typedef Functor1R< Return, Arg1 > SelfType;
   typedef Impl::FunctorBase1R< Return, Arg1 > FunctorImplType;
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;


   Functor1R()
   {
   }

   explicit Functor1R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor1R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl( a1 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Arg1, class Arg2 >
class Functor2 : public FunctorCommon
{
public:
   typedef Functor2< Arg1, Arg2 > SelfType;
   typedef Impl::FunctorBase2< Arg1, Arg2 > FunctorImplType;
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;


   Functor2()
   {
   }

   explicit Functor2( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor2( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl( a1, a2 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return, class Arg1, class Arg2 >
class Functor2R : public FunctorCommon
{
public:
   typedef Functor2R< Return, Arg1, Arg2 > SelfType;
   typedef Impl::FunctorBase2R< Return, Arg1, Arg2 > FunctorImplType;
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;


   Functor2R()
   {
   }

   explicit Functor2R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor2R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl( a1, a2 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Arg1, class Arg2, class Arg3 >
class Functor3 : public FunctorCommon
{
public:
   typedef Functor3< Arg1, Arg2, Arg3 > SelfType;
   typedef Impl::FunctorBase3< Arg1, Arg2, Arg3 > FunctorImplType;
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;


   Functor3()
   {
   }

   explicit Functor3( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor3( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl( a1, a2, a3 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return, class Arg1, class Arg2, class Arg3 >
class Functor3R : public FunctorCommon
{
public:
   typedef Functor3R< Return, Arg1, Arg2, Arg3 > SelfType;
   typedef Impl::FunctorBase3R< Return, Arg1, Arg2, Arg3 > FunctorImplType;
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;


   Functor3R()
   {
   }

   explicit Functor3R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor3R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl( a1, a2, a3 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Arg1, class Arg2, class Arg3, class Arg4 >
class Functor4 : public FunctorCommon
{
public:
   typedef Functor4< Arg1, Arg2, Arg3, Arg4 > SelfType;
   typedef Impl::FunctorBase4< Arg1, Arg2, Arg3, Arg4 > FunctorImplType;
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;


   Functor4()
   {
   }

   explicit Functor4( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor4( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl( a1, a2, a3, a4 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
class Functor4R : public FunctorCommon
{
public:
   typedef Functor4R< Return, Arg1, Arg2, Arg3, Arg4 > SelfType;
   typedef Impl::FunctorBase4R< Return, Arg1, Arg2, Arg3, Arg4 > FunctorImplType;
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;


   Functor4R()
   {
   }

   explicit Functor4R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor4R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl( a1, a2, a3, a4 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
class Functor5 : public FunctorCommon
{
public:
   typedef Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;
   typedef Impl::FunctorBase5< Arg1, Arg2, Arg3, Arg4, Arg5 > FunctorImplType;
   typedef void result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;
   typedef Arg5 arg5_type;


   Functor5()
   {
   }

   explicit Functor5( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor5( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      impl( a1, a2, a3, a4, a5 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


template< class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
class Functor5R : public FunctorCommon
{
public:
   typedef Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 > SelfType;
   typedef Impl::FunctorBase5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 > FunctorImplType;
   typedef Return result_type;
   typedef Arg1 arg1_type;
   typedef Arg1 first_argument_type;
   typedef Arg2 arg2_type;
   typedef Arg2 second_argument_type;
   typedef Arg3 arg3_type;
   typedef Arg4 arg4_type;
   typedef Arg5 arg5_type;


   Functor5R()
   {
   }

   explicit Functor5R( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   Functor5R( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      return impl( a1, a2, a3, a4, a5 );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};




// Functor0


inline Functor0 cfn0( void (*function)(  ) )
{
   typedef void (*Functor)();
   return Functor0( new Impl::GenericFunctor0< Functor >( function ) );
}

template< class Holder, class Object >
inline Functor0
memfn0( const Holder &holder, void (Object::*member)(  ) )
{
   return Functor0( new Impl::MemberFunctor0< Holder, Object >( holder, member ) );
}

template<class Functor>
inline Functor0
fn0( Functor functor )
{

   return Functor0( new Impl::GenericFunctor0< Functor >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind0<Functor
           ,BindArg >
bind1( Functor functor, BindArg arg )
{
   return Impl::Bind0<Functor
           ,BindArg >( functor, arg );
}

// Functor0R

template< class Return >
inline Functor0R< Return > cfn0r( Return (*function)(  ) )
{
   typedef Return (*Functor)();
   return Functor0R< Return >( new Impl::GenericFunctor0R< Functor, Return >( function ) );
}

template< class Holder, class Object, class Return >
inline Functor0R< Return >
memfn0r( const Holder &holder, Return (Object::*member)(  ) )
{
   return Functor0R< Return >( new Impl::MemberFunctor0R< Holder, Object, Return >( holder, member ) );
}

template<class Functor>
inline Functor0R< CPPTL_TYPENAME Functor::result_type >
fn0r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   return Functor0R< Return >( new Impl::GenericFunctor0R< Functor, Return >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind0R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,BindArg >
bind1r( Functor functor, BindArg arg )
{
   return Impl::Bind0R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,BindArg >( functor, arg );
}

// Functor1

template< class Arg1 >
inline Functor1< Arg1 > cfn1( void (*function)( Arg1 a1 ) )
{
   typedef void (*Functor)(Arg1);
   return Functor1< Arg1 >( new Impl::GenericFunctor1< Functor, Arg1 >( function ) );
}

template< class Holder, class Object, class Arg1 >
inline Functor1< Arg1 >
memfn1( const Holder &holder, void (Object::*member)( Arg1 a1 ) )
{
   return Functor1< Arg1 >( new Impl::MemberFunctor1< Holder, Object, Arg1 >( holder, member ) );
}

template<class Functor>
inline Functor1< CPPTL_TYPENAME Functor::first_argument_type >
fn1( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   return Functor1< Arg1 >( new Impl::GenericFunctor1< Functor, Arg1 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind1<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,BindArg >
bind2( Functor functor, BindArg arg )
{
   return Impl::Bind1<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1 >
inline Functor0
bind( Functor functor, Arg1 a1 )
{
    return fn0( bind1( functor, a1 ) );
}

template< class Arg1, class FA1 >
inline Functor0
bind_cfn( void (*function)( FA1 ), Arg1 a1 )
{
    return fn0( bind1( cfn1( function ), a1 ) );
}

template< class Holder, class Object, class Arg1, class FA1 >
inline  Functor0
bind_memfn( const Holder &holder,
             void (Object::*member)( FA1 ),
             Arg1 a1 )
{
    return fn0( bind1( memfn1( holder, member ), a1 ) );
}

// Functor1R

template< class Return, class Arg1 >
inline Functor1R< Return, Arg1 > cfn1r( Return (*function)( Arg1 a1 ) )
{
   typedef Return (*Functor)(Arg1);
   return Functor1R< Return, Arg1 >( new Impl::GenericFunctor1R< Functor, Return, Arg1 >( function ) );
}

template< class Holder, class Object, class Return, class Arg1 >
inline Functor1R< Return, Arg1 >
memfn1r( const Holder &holder, Return (Object::*member)( Arg1 a1 ) )
{
   return Functor1R< Return, Arg1 >( new Impl::MemberFunctor1R< Holder, Object, Return, Arg1 >( holder, member ) );
}

template<class Functor>
inline Functor1R< CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type >
fn1r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   return Functor1R< Return, Arg1 >( new Impl::GenericFunctor1R< Functor, Return, Arg1 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind1R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,BindArg >
bind2r( Functor functor, BindArg arg )
{
   return Impl::Bind1R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1 >
inline Functor0R<CPPTL_TYPENAME Functor::result_type>
bindr( Functor functor, Arg1 a1 )
{
    return fn0r( bind1r( functor, a1 ) );
}

template< class Return, class Arg1, class FA1 >
inline Functor0R<Return>
bind_cfnr( Return (*function)( FA1 ), Arg1 a1 )
{
    return fn0r( bind1r( cfn1r( function ), a1 ) );
}

template< class Holder, class Object, class Return, class Arg1, class FA1 >
inline  Functor0R<Return>
bind_memfnr( const Holder &holder,
             Return (Object::*member)( FA1 ),
             Arg1 a1 )
{
    return fn0r( bind1r( memfn1r( holder, member ), a1 ) );
}

// Functor2

template< class Arg1, class Arg2 >
inline Functor2< Arg1, Arg2 > cfn2( void (*function)( Arg1 a1, Arg2 a2 ) )
{
   typedef void (*Functor)(Arg1,Arg2);
   return Functor2< Arg1, Arg2 >( new Impl::GenericFunctor2< Functor, Arg1, Arg2 >( function ) );
}

template< class Holder, class Object, class Arg1, class Arg2 >
inline Functor2< Arg1, Arg2 >
memfn2( const Holder &holder, void (Object::*member)( Arg1 a1, Arg2 a2 ) )
{
   return Functor2< Arg1, Arg2 >( new Impl::MemberFunctor2< Holder, Object, Arg1, Arg2 >( holder, member ) );
}

template<class Functor>
inline Functor2< CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type >
fn2( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   return Functor2< Arg1, Arg2 >( new Impl::GenericFunctor2< Functor, Arg1, Arg2 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind2<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,BindArg >
bind3( Functor functor, BindArg arg )
{
   return Impl::Bind2<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2 >
inline Functor0
bind( Functor functor, Arg1 a1, Arg2 a2 )
{
    return fn0( bind1( bind2( functor, a2 ), a1 ) );
}

template< class Arg1, class Arg2, class FA1, class FA2 >
inline Functor0
bind_cfn( void (*function)( FA1, FA2 ), Arg1 a1, Arg2 a2 )
{
    return fn0( bind1( bind2( cfn2( function ), a2 ), a1 ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class FA1, class FA2 >
inline  Functor0
bind_memfn( const Holder &holder,
             void (Object::*member)( FA1, FA2 ),
             Arg1 a1, Arg2 a2 )
{
    return fn0( bind1( bind2( memfn2( holder, member ), a2 ), a1 ) );
}

// Functor2R

template< class Return, class Arg1, class Arg2 >
inline Functor2R< Return, Arg1, Arg2 > cfn2r( Return (*function)( Arg1 a1, Arg2 a2 ) )
{
   typedef Return (*Functor)(Arg1,Arg2);
   return Functor2R< Return, Arg1, Arg2 >( new Impl::GenericFunctor2R< Functor, Return, Arg1, Arg2 >( function ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2 >
inline Functor2R< Return, Arg1, Arg2 >
memfn2r( const Holder &holder, Return (Object::*member)( Arg1 a1, Arg2 a2 ) )
{
   return Functor2R< Return, Arg1, Arg2 >( new Impl::MemberFunctor2R< Holder, Object, Return, Arg1, Arg2 >( holder, member ) );
}

template<class Functor>
inline Functor2R< CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type >
fn2r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   return Functor2R< Return, Arg1, Arg2 >( new Impl::GenericFunctor2R< Functor, Return, Arg1, Arg2 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind2R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,BindArg >
bind3r( Functor functor, BindArg arg )
{
   return Impl::Bind2R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2 >
inline Functor0R<CPPTL_TYPENAME Functor::result_type>
bindr( Functor functor, Arg1 a1, Arg2 a2 )
{
    return fn0r( bind1r( bind2r( functor, a2 ), a1 ) );
}

template< class Return, class Arg1, class Arg2, class FA1, class FA2 >
inline Functor0R<Return>
bind_cfnr( Return (*function)( FA1, FA2 ), Arg1 a1, Arg2 a2 )
{
    return fn0r( bind1r( bind2r( cfn2r( function ), a2 ), a1 ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class FA1, class FA2 >
inline  Functor0R<Return>
bind_memfnr( const Holder &holder,
             Return (Object::*member)( FA1, FA2 ),
             Arg1 a1, Arg2 a2 )
{
    return fn0r( bind1r( bind2r( memfn2r( holder, member ), a2 ), a1 ) );
}

// Functor3

template< class Arg1, class Arg2, class Arg3 >
inline Functor3< Arg1, Arg2, Arg3 > cfn3( void (*function)( Arg1 a1, Arg2 a2, Arg3 a3 ) )
{
   typedef void (*Functor)(Arg1,Arg2,Arg3);
   return Functor3< Arg1, Arg2, Arg3 >( new Impl::GenericFunctor3< Functor, Arg1, Arg2, Arg3 >( function ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3 >
inline Functor3< Arg1, Arg2, Arg3 >
memfn3( const Holder &holder, void (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3 ) )
{
   return Functor3< Arg1, Arg2, Arg3 >( new Impl::MemberFunctor3< Holder, Object, Arg1, Arg2, Arg3 >( holder, member ) );
}

template<class Functor>
inline Functor3< CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type >
fn3( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   return Functor3< Arg1, Arg2, Arg3 >( new Impl::GenericFunctor3< Functor, Arg1, Arg2, Arg3 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind3<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,BindArg >
bind4( Functor functor, BindArg arg )
{
   return Impl::Bind3<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3 >
inline Functor0
bind( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0( bind1( bind2( bind3( functor, a3 ), a2 ), a1 ) );
}

template< class Arg1, class Arg2, class Arg3, class FA1, class FA2, class FA3 >
inline Functor0
bind_cfn( void (*function)( FA1, FA2, FA3 ), Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0( bind1( bind2( bind3( cfn3( function ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class FA1, class FA2, class FA3 >
inline  Functor0
bind_memfn( const Holder &holder,
             void (Object::*member)( FA1, FA2, FA3 ),
             Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0( bind1( bind2( bind3( memfn3( holder, member ), a3 ), a2 ), a1 ) );
}

// Functor3R

template< class Return, class Arg1, class Arg2, class Arg3 >
inline Functor3R< Return, Arg1, Arg2, Arg3 > cfn3r( Return (*function)( Arg1 a1, Arg2 a2, Arg3 a3 ) )
{
   typedef Return (*Functor)(Arg1,Arg2,Arg3);
   return Functor3R< Return, Arg1, Arg2, Arg3 >( new Impl::GenericFunctor3R< Functor, Return, Arg1, Arg2, Arg3 >( function ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3 >
inline Functor3R< Return, Arg1, Arg2, Arg3 >
memfn3r( const Holder &holder, Return (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3 ) )
{
   return Functor3R< Return, Arg1, Arg2, Arg3 >( new Impl::MemberFunctor3R< Holder, Object, Return, Arg1, Arg2, Arg3 >( holder, member ) );
}

template<class Functor>
inline Functor3R< CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type >
fn3r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   return Functor3R< Return, Arg1, Arg2, Arg3 >( new Impl::GenericFunctor3R< Functor, Return, Arg1, Arg2, Arg3 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind3R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,BindArg >
bind4r( Functor functor, BindArg arg )
{
   return Impl::Bind3R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3 >
inline Functor0R<CPPTL_TYPENAME Functor::result_type>
bindr( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0r( bind1r( bind2r( bind3r( functor, a3 ), a2 ), a1 ) );
}

template< class Return, class Arg1, class Arg2, class Arg3, class FA1, class FA2, class FA3 >
inline Functor0R<Return>
bind_cfnr( Return (*function)( FA1, FA2, FA3 ), Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0r( bind1r( bind2r( bind3r( cfn3r( function ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class FA1, class FA2, class FA3 >
inline  Functor0R<Return>
bind_memfnr( const Holder &holder,
             Return (Object::*member)( FA1, FA2, FA3 ),
             Arg1 a1, Arg2 a2, Arg3 a3 )
{
    return fn0r( bind1r( bind2r( bind3r( memfn3r( holder, member ), a3 ), a2 ), a1 ) );
}

// Functor4

template< class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor4< Arg1, Arg2, Arg3, Arg4 > cfn4( void (*function)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) )
{
   typedef void (*Functor)(Arg1,Arg2,Arg3,Arg4);
   return Functor4< Arg1, Arg2, Arg3, Arg4 >( new Impl::GenericFunctor4< Functor, Arg1, Arg2, Arg3, Arg4 >( function ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor4< Arg1, Arg2, Arg3, Arg4 >
memfn4( const Holder &holder, void (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) )
{
   return Functor4< Arg1, Arg2, Arg3, Arg4 >( new Impl::MemberFunctor4< Holder, Object, Arg1, Arg2, Arg3, Arg4 >( holder, member ) );
}

template<class Functor>
inline Functor4< CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type >
fn4( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   typedef CPPTL_TYPENAME Functor::arg4_type Arg4;
   return Functor4< Arg1, Arg2, Arg3, Arg4 >( new Impl::GenericFunctor4< Functor, Arg1, Arg2, Arg3, Arg4 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind4<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,BindArg >
bind5( Functor functor, BindArg arg )
{
   return Impl::Bind4<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor0
bind( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0( bind1( bind2( bind3( bind4( functor, a4 ), a3 ), a2 ), a1 ) );
}

template< class Arg1, class Arg2, class Arg3, class Arg4, class FA1, class FA2, class FA3, class FA4 >
inline Functor0
bind_cfn( void (*function)( FA1, FA2, FA3, FA4 ), Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0( bind1( bind2( bind3( bind4( cfn4( function ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4, class FA1, class FA2, class FA3, class FA4 >
inline  Functor0
bind_memfn( const Holder &holder,
             void (Object::*member)( FA1, FA2, FA3, FA4 ),
             Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0( bind1( bind2( bind3( bind4( memfn4( holder, member ), a4 ), a3 ), a2 ), a1 ) );
}

// Functor4R

template< class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor4R< Return, Arg1, Arg2, Arg3, Arg4 > cfn4r( Return (*function)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) )
{
   typedef Return (*Functor)(Arg1,Arg2,Arg3,Arg4);
   return Functor4R< Return, Arg1, Arg2, Arg3, Arg4 >( new Impl::GenericFunctor4R< Functor, Return, Arg1, Arg2, Arg3, Arg4 >( function ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor4R< Return, Arg1, Arg2, Arg3, Arg4 >
memfn4r( const Holder &holder, Return (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 ) )
{
   return Functor4R< Return, Arg1, Arg2, Arg3, Arg4 >( new Impl::MemberFunctor4R< Holder, Object, Return, Arg1, Arg2, Arg3, Arg4 >( holder, member ) );
}

template<class Functor>
inline Functor4R< CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type >
fn4r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   typedef CPPTL_TYPENAME Functor::arg4_type Arg4;
   return Functor4R< Return, Arg1, Arg2, Arg3, Arg4 >( new Impl::GenericFunctor4R< Functor, Return, Arg1, Arg2, Arg3, Arg4 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind4R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,BindArg >
bind5r( Functor functor, BindArg arg )
{
   return Impl::Bind4R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4 >
inline Functor0R<CPPTL_TYPENAME Functor::result_type>
bindr( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( functor, a4 ), a3 ), a2 ), a1 ) );
}

template< class Return, class Arg1, class Arg2, class Arg3, class Arg4, class FA1, class FA2, class FA3, class FA4 >
inline Functor0R<Return>
bind_cfnr( Return (*function)( FA1, FA2, FA3, FA4 ), Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( cfn4r( function ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class FA1, class FA2, class FA3, class FA4 >
inline  Functor0R<Return>
bind_memfnr( const Holder &holder,
             Return (Object::*member)( FA1, FA2, FA3, FA4 ),
             Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( memfn4r( holder, member ), a4 ), a3 ), a2 ), a1 ) );
}

// Functor5

template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 > cfn5( void (*function)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) )
{
   typedef void (*Functor)(Arg1,Arg2,Arg3,Arg4,Arg5);
   return Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::GenericFunctor5< Functor, Arg1, Arg2, Arg3, Arg4, Arg5 >( function ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 >
memfn5( const Holder &holder, void (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) )
{
   return Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::MemberFunctor5< Holder, Object, Arg1, Arg2, Arg3, Arg4, Arg5 >( holder, member ) );
}

template<class Functor>
inline Functor5< CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type >
fn5( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   typedef CPPTL_TYPENAME Functor::arg4_type Arg4;
   typedef CPPTL_TYPENAME Functor::arg5_type Arg5;
   return Functor5< Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::GenericFunctor5< Functor, Arg1, Arg2, Arg3, Arg4, Arg5 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind5<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type
           ,BindArg >
bind6( Functor functor, BindArg arg )
{
   return Impl::Bind5<Functor
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor0
bind( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0( bind1( bind2( bind3( bind4( bind5( functor, a5 ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class FA1, class FA2, class FA3, class FA4, class FA5 >
inline Functor0
bind_cfn( void (*function)( FA1, FA2, FA3, FA4, FA5 ), Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0( bind1( bind2( bind3( bind4( bind5( cfn5( function ), a5 ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class FA1, class FA2, class FA3, class FA4, class FA5 >
inline  Functor0
bind_memfn( const Holder &holder,
             void (Object::*member)( FA1, FA2, FA3, FA4, FA5 ),
             Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0( bind1( bind2( bind3( bind4( bind5( memfn5( holder, member ), a5 ), a4 ), a3 ), a2 ), a1 ) );
}

// Functor5R

template< class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 > cfn5r( Return (*function)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) )
{
   typedef Return (*Functor)(Arg1,Arg2,Arg3,Arg4,Arg5);
   return Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::GenericFunctor5R< Functor, Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( function ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >
memfn5r( const Holder &holder, Return (Object::*member)( Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 ) )
{
   return Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::MemberFunctor5R< Holder, Object, Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( holder, member ) );
}

template<class Functor>
inline Functor5R< CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type >
fn5r( Functor functor )
{
   typedef CPPTL_TYPENAME Functor::result_type Return;
   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
   typedef CPPTL_TYPENAME Functor::second_argument_type Arg2;
   typedef CPPTL_TYPENAME Functor::arg3_type Arg3;
   typedef CPPTL_TYPENAME Functor::arg4_type Arg4;
   typedef CPPTL_TYPENAME Functor::arg5_type Arg5;
   return Functor5R< Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( new Impl::GenericFunctor5R< Functor, Return, Arg1, Arg2, Arg3, Arg4, Arg5 >( functor ) );
}

template<class Functor, class BindArg>
inline Impl::Bind5R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type
           ,BindArg >
bind6r( Functor functor, BindArg arg )
{
   return Impl::Bind5R<Functor
           ,CPPTL_TYPENAME Functor::result_type
           ,CPPTL_TYPENAME Functor::first_argument_type
           ,CPPTL_TYPENAME Functor::second_argument_type
           ,CPPTL_TYPENAME Functor::arg3_type
           ,CPPTL_TYPENAME Functor::arg4_type
           ,CPPTL_TYPENAME Functor::arg5_type
           ,BindArg >( functor, arg );
}

template< class Functor, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5 >
inline Functor0R<CPPTL_TYPENAME Functor::result_type>
bindr( Functor functor, Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( bind5r( functor, a5 ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class FA1, class FA2, class FA3, class FA4, class FA5 >
inline Functor0R<Return>
bind_cfnr( Return (*function)( FA1, FA2, FA3, FA4, FA5 ), Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( bind5r( cfn5r( function ), a5 ), a4 ), a3 ), a2 ), a1 ) );
}

template< class Holder, class Object, class Return, class Arg1, class Arg2, class Arg3, class Arg4, class Arg5, class FA1, class FA2, class FA3, class FA4, class FA5 >
inline  Functor0R<Return>
bind_memfnr( const Holder &holder,
             Return (Object::*member)( FA1, FA2, FA3, FA4, FA5 ),
             Arg1 a1, Arg2 a2, Arg3 a3, Arg4 a4, Arg5 a5 )
{
    return fn0r( bind1r( bind2r( bind3r( bind4r( bind5r( memfn5r( holder, member ), a5 ), a4 ), a3 ), a2 ), a1 ) );
}




} // namespace CppTL


#endif // CPPTL_FUNCTOR_H_INCLUDED


@


1.5
log
@* fixed bad return statement in void Functor.
@
text
@d45 1
d1166 1
@


1.4
log
@* allow up to 5 arguments.
@
text
@d1252 1
a1252 1
      return impl(  );
d1340 1
a1340 1
      return impl( a1 );
d1432 1
a1432 1
      return impl( a1, a2 );
d1527 1
a1527 1
      return impl( a1, a2, a3 );
d1624 1
a1624 1
      return impl( a1, a2, a3, a4 );
d1723 1
a1723 1
      return impl( a1, a2, a3, a4, a5 );
@


1.3
log
@* changed cppunit 2 to use the new functors (cpptl/functor.h). bind_cfn & bind_memfn simplified some of the test code.
@
text
@d597 564
d1489 294
d2101 432
@


1.2
log
@* simpler implementation of functors.
* complete rewrote of the generator (much easier to maintain)
@
text
@d1030 23
d1092 23
d1154 23
d1220 23
@


1.1
log
@* simpler implementation of functors.
* complete rewrote of the generator (much easier to maintain)
@
text
@d10 35
d121 24
d209 24
d297 26
d387 210
d831 94
d951 8
a958 1

d984 10
a993 1

d1019 10
a1028 1

d1056 12
d1069 81
@

