head	1.4;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.4;
locks; strict;
comment	@# @;


1.4
date	2005.03.05.13.44.50;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.05.10.15.12;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.05.09.41.00;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.04.07.30.32;	author blep;	state Exp;
branches;
next	;


desc
@@


1.4
log
@* added portability macro CPPTL_AT to access sequence container portably
@
text
@# script to generate cpptl/reflectionimpl10.h

MIN_ARGUMENT_COUNT = 0
MAX_ARGUMENT_COUNT = 10

header =\
"""// This script is generated by the python script reflectionimpl.py
// Do not edit.
#ifndef CPPTL_REFLECTIONIMPL%(MAX_ARGUMENT_COUNT)d_H_INCLUDED
# define CPPTL_REFLECTIONIMPL%(MAX_ARGUMENT_COUNT)d_H_INCLUDED

namespace CppTL { namespace Impl {

%(invokables)s

template< class Arg>
void setReturnType( Invokable &invokable, Type<Arg> )
{
   invokable.returnType_ = typeId( Type<Arg>() );
}

template< class Arg1 >
void registerArgTypes( Invokable &invokable, Type<Arg1> )
{
   invokable.argTypes_.push_back( typeId( Type<Arg1>() ) );
}

template< class Arg1, class Arg2 >
void registerArgTypes( Invokable &invokable, Type<Arg1>, Type<Arg2> )
{
   registerArgTypes( invokable, Type<Arg1>() );
   registerArgTypes( invokable, Type<Arg2>() );

}

template< class Arg1, class Arg2, class Arg3 >
void registerArgTypes( Invokable &invokable, Type<Arg1>, Type<Arg2>, Type<Arg3> )
{
   registerArgTypes( invokable, Type<Arg1>(), Type<Arg2>() );
   registerArgTypes( invokable, Type<Arg3>() );

}


%(invokable_generators)s

} // namespace Impl
} // namespace CppTL

#endif // CPPTL_REFLECTIONIMPL%(MAX_ARGUMENT_COUNT)d_H_INCLUDED
"""

invokable =\
"""   %(invokable_template_decl)s
   class %(invokable)s : public InvokableBase
   {
   public:
      typedef %(return_type)s (Object::*Member)( %(fn_parameter_types)s )%(const_method)s;

      %(invokable)s( Member member )
         : member_( member )
      {
      }

      void invoke( MethodCall &call ) const
      {
         Object &object = *any_cast( call.holder_, Type<Object *>() );
         %(return_keyword)s(object.*member_)( %(fn_call)s );
      }

   private:
      Member member_;
   };
   
"""
# invokable_template_decl :
#   template<class Object
#         ,class Arg1
#         ,class Arg2>
# invokable : Invokable2
# return_type : void
# fn_parameter_types : Arg1, Arg2
# const_method : const
# return_keyword : return 
# fn_call :
#   any_cast( call.args_.at(0), Type<Arg1>() ),
#   any_cast( call.args_.at(1), Type<Arg2>() )

invokable_generator = \
"""
%(invokable_template_decl)s
Invokable makeInvokable%(return_suffix)s( %(return_type)s (Object::*member)( %(fn_parameter_types)s )%(const_method)s )
{
   Invokable invokable( InvokableBasePtr( new %(invokable_instantiation)s( member ) ) );
%(push_back_parameter_types)s%(set_return_type)s   return invokable;
}
"""
# invokable_instantiation : Invokable2<Object,Arg1,Arg2>
# push_back_parameter_types :
#      invokable.argTypes_.push_back( typeId( Type<Arg1>() ) );
#      invokable.argTypes_.push_back( typeId( Type<Arg2>() ) );
# set_return_type:
#      setReturnType( invokable, Type<Return>() );

class GenerationParameters(object):
    def __init__( self, count, is_const, has_return ):
        self.count = count
        self.is_const = is_const

        args = [ 'Arg%d' % n for n in xrange(1,count+1) ]
        return_param = (has_return and ['Return']) or []
        return_suffix = (has_return and 'R') or ''
        self.return_suffix = return_suffix
        self.return_type = (has_return and 'Return') or 'void'
        self.return_keyword = (has_return and 'call.result_ = ') or ''
        invokable_template_parameters = ['Object'] + return_param + args
        self.invokable_template_decl = self.makeTemplateDecl( invokable_template_parameters )
        if is_const:
            self.invokable = 'InvokableConst%d%s' % (count,return_suffix)
        else:
            self.invokable = 'Invokable%d%s' % (count,return_suffix)
        self.fn_parameter_types = ', '.join( args )
        self.const_method = (is_const and ' const') or ''
        self.fn_call = '\n            ,'.join( [ 'any_cast( CPPTL_AT( call.args_, %d ), Type<Arg%d>() )' % (n,n+1)
                                                 for n in xrange(0,count) ] )
        self.invokable_instantiation = self.invokable + self.makeTemplateInstantiation( invokable_template_parameters )
        self.push_back_parameter_types = self.makePushBackParameterTypes( args )
        self.set_return_type = (has_return and '   setReturnType( invokable, Type<Return>() );\n') or ''

    def __getitem__( self, key ):
        return getattr( self, key )

    def makeTemplateDecl( self, parameters ):
        if not parameters:
            return ''
        return 'template< class ' + ', class '.join( parameters ) + ' >'

    def makeTemplateInstantiation( self, parameters ):
        if not parameters:
            return ''
        return '< ' + ', '.join( parameters ) + ' >'

    def makePushBackParameterTypes( self, args ):
        args = args[:]
        source = ''
        for limit in (3,2,1):
            while len(args) >= limit:
                source += '   registerArgTypes( invokable, %s );\n' % ', '.join(
                    [ 'Type<%s>()' % type for type in args[0:limit] ])
                args = args[limit:]
        return source
            
invokables = ''
invokable_generators = ''

for argument_count in xrange(MIN_ARGUMENT_COUNT,MAX_ARGUMENT_COUNT+1):
    for is_const in (False,True):
        for has_return in (False,True):
            parameters = GenerationParameters( argument_count, is_const, has_return )
            invokables += invokable % parameters
            invokable_generators += invokable_generator % parameters

final_header = header % locals()

out = file( 'reflectionimpl%d.h' % MAX_ARGUMENT_COUNT, 'wt')
out.write( final_header )
out.close()
@


1.3
log
@* added support for reflection of method with return value
@
text
@d124 1
a124 1
        self.fn_call = '\n            ,'.join( [ 'any_cast( call.args_.at(%d), Type<Arg%d>() )' % (n,n+1)
@


1.2
log
@* added support for reflection of const methods
* factorised parameter type registration for better template function reuse.
@
text
@d16 5
d58 1
a58 1
      typedef void (Object::*Member)( %(fn_parameter_types)s )%(const_method)s;
d68 1
a68 1
         (object.*member_)( %(fn_call)s );
d81 1
d84 1
d92 1
a92 1
Invokable makeInvokable( void (Object::*member)( %(fn_parameter_types)s )%(const_method)s )
d95 1
a95 2
%(push_back_parameter_types)s
   return invokable;
d102 2
d106 1
a106 1
    def __init__( self, count, is_const ):
d111 6
a116 1
        invokable_template_parameters = ['Object'] + args
d119 1
a119 1
            self.invokable = 'InvokableConst%d' % count
d121 1
a121 1
            self.invokable = 'Invokable%d' % count
d128 1
d158 4
a161 3
        parameters = GenerationParameters( argument_count, is_const )
        invokables += invokable % parameters
        invokable_generators += invokable_generator % parameters
@


1.1
log
@* extracted invokable subclass in a specific generated header.
@
text
@d16 24
d53 1
a53 1
      typedef void (Object::*Member)( %(fn_parameter_types)s );
d77 1
a81 1

d85 1
a85 1
Invokable makeInvokable( void (Object::*member)( %(fn_parameter_types)s ) )
d98 1
a98 1
    def __init__( self, count ):
d100 1
d102 2
a103 1
        invokable_template_parameters = ['Object'] + [ 'Arg%d' % n for n in xrange(1,count+1) ]
d105 6
a110 2
        self.invokable = 'Invokable%d' % count
        self.fn_parameter_types = ', '.join( [ 'Arg%d' % n for n in xrange(1,count+1) ] )
d114 1
a114 3
        self.push_back_parameter_types = '\n'.join(
            [ '   invokable.argTypes_.push_back( typeId( Type<Arg%d>() ) );' % (n+1)
              for n in xrange(0,count) ] )
d128 10
d143 4
a146 3
    parameters = GenerationParameters( argument_count )
    invokables += invokable % parameters
    invokable_generators += invokable_generator % parameters
@

