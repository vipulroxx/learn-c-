head	1.6;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.6
	CPPUNIT2_TG_AFTER_CONSTSTRING:1.2
	CPPUNIT2_TG_BEFORE_CONSTSTRING:1.2;
locks; strict;
comment	@# @;


1.6
date	2005.11.13.10.12.01;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.04.22.17.54;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.28.20.33.47;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.27.14.38.25;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.26.11.40.58;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.25.20.53.57;	author blep;	state Exp;
branches;
next	;


desc
@@


1.6
log
@- renamed include/cpput/assert.h to include/cpput/assertcommon.h. This avoid clash with include <assert.h> in doxygen documentation
- most Impl namespaces are now hidden from documentation using \cond and \endcond.
@
text
@# script to generate cpptl/functor.h

MAX_ARGUMENT_COUNT = 5

header =\
"""// This script is generated by the python script functor.py
// Do not edit.
#ifndef CPPTL_FUNCTOR_H_INCLUDED
# define CPPTL_FUNCTOR_H_INCLUDED

# include <cpptl/config.h>

namespace CppTL {

// Partially borrowed from the standard
// See: 
// N1453: http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1453.html
template<class T>
class ReferenceWrapper
{
public:
  explicit ReferenceWrapper( T &t ) : t_( &t )
  {
  }

  operator T&() const
  {
     return *t_;
  }

private:
  T *t_;
};

template<class T>
inline ReferenceWrapper<T> 
ref( T &t )
{
  return ReferenceWrapper<T>( t );
}

template<class T>
inline ReferenceWrapper<const T>
cref( const T& t )
{
  return ReferenceWrapper<const T>( t );
}


/// \cond implementation_detail
namespace Impl {

   class FunctorBase
   {
   public:
      virtual ~FunctorBase()
      {
      }

      virtual FunctorBase *clone() const = 0;
   };

%(functors_impl)s


} // namespace Impl
/// \endcond


class FunctorCommon
{
public:
   ~FunctorCommon()
   {
      delete impl_;
   }

   bool empty() const
   {
      return impl_ == 0;
   }

   operator bool() const
   {
      return impl_ != 0;   
   }

   bool operator !() const
   {
      return impl_ == 0;
   }

protected:
   FunctorCommon()
      : impl_( 0 )
   {
   }

   FunctorCommon( Impl::FunctorBase *impl )
      : impl_( impl )
   {
   }

   FunctorCommon( const FunctorCommon &other )
      : impl_( other.impl_ ? other.impl_->clone() : 0 )
   {
   }

   void swap( FunctorCommon &other )
   {
      Impl::FunctorBase *temp = impl_;
      impl_ = other.impl_;
      other.impl_ = temp;
   }

   Impl::FunctorBase *impl_;

private:
   void operator =( const FunctorCommon &other );
};

%(functors)s

%(functor_generators)s


} // namespace CppTL


#endif // CPPTL_FUNCTOR_H_INCLUDED


"""

functor_base =\
"""   %(base_template_decl)s
   class %(impl_base)s : public FunctorBase
   {
   public:
      virtual %(return_type)s operator()( %(fn_parameters)s ) const = 0;
   };

   
"""
# base_template_decl : template<class ReturnType, class Arg1Type>
# impl_base : Functor1BaseR
# return_type : ReturnType
# fn_parameters: Arg1 a1

generic_functor = \
"""   %(generic_functor_template_decl)s
   class %(generic_functor)s : public %(impl_base_instantiation)s
   {
   public:
      typedef %(generic_functor_instantiation)s SelfType;

      %(generic_functor)s( const Functor &functor )
         : functor_( functor )
      {
      }

      %(return_type)s operator()( %(fn_parameters)s ) const
      {
         %(return_keyword)sfunctor_( %(fn_call)s );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Functor functor_;
   };

   
"""
# generic_functor_template_decl : template<class Functor, class ReturnType, class Arg1Type>
# generic_functor : GenericFunctor1R
# impl_base_instantiation : Functor1BaseR<ReturnType,Arg1Type>
# generic_functor_instantiation : GenericFunctor1R<Functor,ReturnType,Arg1Type>
# return_keyword : return
# fn_call : a1

member_functor = \
"""   %(member_functor_template_decl)s
   class %(member_functor)s : public %(impl_base_instantiation)s
   {
   public:
      typedef %(member_functor_instantiation)s SelfType;
      typedef %(return_type)s (Object::*MemberFn)( %(fn_parameters)s );

      %(member_functor)s( const Holder &holder, MemberFn member )
         : holder_( holder )
         , member_( member )
      {
      }

      %(return_type)s operator()( %(fn_parameters)s ) const
      {
         Object &object = *holder_;
         %(return_keyword)s(object.*member_)( %(fn_call)s );
      }

      FunctorBase *clone() const
      {
         return new SelfType( *this );
      }

   private:
      Holder holder_;
      MemberFn member_;
   };

   
"""
# member_functor_template_decl : template<class HolderType, class ObjectType, class ReturnType, class Arg1Type>
# member_functor : MemberFunctor1R
# member_functor_instantiation : MemberFunctor1R<HolderType,ObjectType,ReturnType,Arg1Type>

bind_functor = \
"""   %(bind_functor_template_decl)s
   class %(bind_functor)s
   {
   public:
   typedef %(return_type)s result_type;
%(argument_types_typedef)s

      %(bind_functor)s( Functor functor, BindArg arg )
         : functor_( functor )
         , arg_( arg )
      {
      }

      result_type operator()( %(fn_parameters)s ) const
      {
         %(return_keyword)sfunctor_( %(bind_fn_call)s );
      }
   private:
      Functor functor_;
      BindArg arg_;
   };


   
"""
# bind_functor : BindR1
# bind_functor_template_decl : template<class Functor,class ReturnType, class Arg1, class BindArg>
# bind_fn_call: a1, arg_

functor = \
"""%(functor_template_decl)s
class %(functor)s : public FunctorCommon
{
public:
   typedef %(functor_instantiation)s SelfType;
   typedef Impl::%(impl_base_instantiation)s FunctorImplType;
   typedef %(return_type)s result_type;
%(argument_types_typedef)s

   %(functor)s()
   {
   }

   explicit %(functor)s( FunctorImplType *impl )
      : FunctorCommon( impl )
   {
   }

   %(functor)s( const SelfType &other )
      : FunctorCommon( other )
   {
   }

   SelfType &operator=( const SelfType &other )
   {
      SelfType temp( other );
      swap( temp );
      return *this;
   }

   result_type operator()( %(fn_parameters)s ) const
   {
      FunctorImplType &impl = *( static_cast<FunctorImplType *>(impl_) );
      %(return_keyword)simpl( %(fn_call)s );
   }

   void swap( SelfType &other )
   {
      FunctorCommon::swap( other );
   }
};


"""
# functor_template_decl : template<class ReturnType, class Arg1Type>
# functor : Functor1R
# functor_instantiation : Functor1R<ReturnType,Arg1Type>
# argument_types_typedef :
#   typedef Arg1Type first_argument_type;
#   typedef Arg1Type arg1_type;


generator = \
"""// %(functor)s

%(functor_template_decl)s
inline %(functor_instantiation)s %(cfn)s( %(return_type)s (*function)( %(fn_parameters)s ) )
{
   typedef %(return_type)s (*Functor)(%(fn_types)s);
   return %(functor_instantiation)s( new Impl::%(generic_functor_instantiation)s( function ) );
}

%(member_functor_template_decl)s
inline %(functor_instantiation)s
%(memfn)s( const Holder &holder, %(return_type)s (Object::*member)( %(fn_parameters)s ) )
{
   return %(functor_instantiation)s( new Impl::%(member_functor_instantiation)s( holder, member ) );
}

template<class Functor>
inline %(functor)s%(functor_deduced_types)s
%(fn)s( Functor functor )
{
%(functor_deduced_type_alias)s
   return %(functor_instantiation)s( new Impl::%(generic_functor_instantiation)s( functor ) );
}

template<class Functor, class BindArg>
inline Impl::%(bind_functor)s%(bind_functor_deduced_types)s
%(bind)s( Functor functor, BindArg arg )
{
   return Impl::%(bind_functor)s%(bind_functor_deduced_types)s( functor, arg );
}

"""
# cfn : cfn1r
# fn_types : Arg1
# memfn : memfn1r
# fn : fn1r
# functor_deduced_types :
# CPPTL_TYPENAME Functor::result_type
#   ,CPPTL_TYPENAME Functor::first_argument_type
# functor_deduced_type_alias : 
#   typedef CPPTL_TYPENAME Functor::result_type Return;
#   typedef CPPTL_TYPENAME Functor::first_argument_type Arg1;
# bind : bind1r
# bind_functor_deduced_types : 
# CPPTL_TYPENAME Functor::result_type
#   ,CPPTL_TYPENAME Functor::first_argument_type
#   ,BindArg

multi_bind_generator = \
"""%(multi_bind_template_decl)s
inline %(multi_bind_functor_instantiation)s
%(multi_bind)s( Functor functor, %(fn_parameters)s )
{
    return %(multi_bind_fn)s( %(multi_functor_generation)s );
}

%(multi_bind_cfn_template_decl)s
inline %(multi_bind_cfn_instantiation)s
%(multi_bind_cfn)s( %(return_type)s (*function)( %(multi_bind_fn_parameter_types)s ), %(fn_parameters)s )
{
    return %(multi_bind_fn)s( %(multi_cfn_functor_generation)s );
}

%(multi_bind_memfn_template_decl)s
inline  %(multi_bind_cfn_instantiation)s
%(multi_bind_memfn)s( const Holder &holder,
             %(return_type)s (Object::*member)( %(multi_bind_fn_parameter_types)s ),
             %(fn_parameters)s )
{
    return %(multi_bind_fn)s( %(multi_memfn_functor_generation)s );
}

"""
# multi_bind_template_decl : template<class Functor, class Return, class Arg1>
# multi_bind_functor_instantiation : Functor0R<CPPTL_TYPENAME Functor::result_type>
# multi_bind : bindr
# multi_bind_fn : fn0r
# multi_functor_generation : bind1r( bind2r( functor, a2 ), a1 )
# multi_bind_cfn_template_decl : template<class Return, class FA1, class FA2, class Arg1, class Arg2>
# multi_bind_cfn_instantiation : Functor0R<Return>
# multi_bind_cfn : bind_cfnr
# multi_bind_fn_parameter_types : Arg1, Arg2
# multi_cfn_functor_generation : bind1r( bind2r( cfn2r(function), a2 ), a1 )
# multi_bind_memfn_template_decl : template<class Holder, class Object, class Return, class FA1, class FA2, class Arg1, class Arg2>
# multi_bind_memfn : bind_memfnr
# multi_memfn_functor_generation : bind1r( bind2r( memfn2r(member), a2 ), a1 )



class GenerationParameters(object):
    def __init__( self, count, is_void ):
        self.count = count
        self.is_void = is_void
        self.return_type = (is_void and 'void') or 'Return'
        self.fn_parameters = ', '.join( [ 'Arg%d a%d' % (n,n) for n in xrange(1,count+1) ] )
        self.fn_call = ', '.join( [ 'a%d' % n for n in xrange(1,count+1) ] )
        base_template_parameters = []
        return_suffix = (not is_void and 'R') or ''
        self.impl_base = 'FunctorBase%d%s' % (count,return_suffix)
        self.return_keyword = (not is_void and 'return ') or ''
        if not is_void:
            base_template_parameters.append( 'Return' )
        args_template_parameters = [ 'Arg%d' % n for n in xrange(1,count+1) ]
        base_template_parameters.extend( args_template_parameters )
        self.base_template_decl = self.makeTemplateDecl( base_template_parameters )
        self.impl_base_instantiation = self.impl_base + self.makeTemplateInstantiation( base_template_parameters )
        generic_functor_template_parameters = ['Functor'] + base_template_parameters
        self.generic_functor_template_decl = self.makeTemplateDecl( generic_functor_template_parameters )
        self.generic_functor = 'GenericFunctor%d%s' % (count,return_suffix)
        self.generic_functor_instantiation = self.generic_functor + \
                                             self.makeTemplateInstantiation(generic_functor_template_parameters )
        self.member_functor = 'MemberFunctor%d%s' % (count,return_suffix)
        member_functor_template_parameters = ['Holder','Object'] + base_template_parameters
        self.member_functor_template_decl = self.makeTemplateDecl( member_functor_template_parameters )
        self.member_functor_instantiation = self.member_functor + \
                                             self.makeTemplateInstantiation(member_functor_template_parameters )
        self.functor = 'Functor%d%s' % (count,return_suffix)
        self.functor_template_decl = self.makeTemplateDecl( base_template_parameters )
        self.functor_instantiation = self.functor + self.makeTemplateInstantiation( base_template_parameters )
        self.bind_functor = 'Bind%d%s' % (count,return_suffix)
        bind_functor_template_parameters = ['Functor'] + base_template_parameters + ['BindArg']
        self.bind_functor_template_decl = self.makeTemplateDecl( bind_functor_template_parameters )
        self.bind_fn_call = ', '.join( [ 'a%d' % n for n in xrange(1,count+1) ] + ['arg_'] )
        self.argument_types_typedef = ''
        for n in xrange(1,count+1):
            self.argument_types_typedef += self.makeArgumentTypedef( n )
        self.cfn = 'cfn%d%s' % (count,return_suffix.lower()) 
        self.memfn = 'memfn%d%s' % (count,return_suffix.lower()) 
        self.fn = 'fn%d%s' % (count,return_suffix.lower()) 
        self.bind = 'bind%d%s' % (count+1,return_suffix.lower()) 
        self.fn_types = ','.join( [ 'Arg%d' % n for n in xrange(1,count+1) ] )
        functor_deduced_types = []
        if not is_void:
            functor_deduced_types.append( 'CPPTL_TYPENAME Functor::result_type' )
        for n in xrange(1,count+1):
            functor_deduced_types.append( 'CPPTL_TYPENAME Functor::%s' % self.getFunctorArgTypeName(n) )
        if len(functor_deduced_types):
            self.functor_deduced_types = '< ' + '\n           ,'.join( functor_deduced_types ) + ' >'
        else:
            self.functor_deduced_types = ''
        functor_deduced_type_alias = []
        if not is_void:
            functor_deduced_type_alias.append('   typedef CPPTL_TYPENAME Functor::result_type Return;')
        for n in xrange(1,count+1):
            functor_deduced_type_alias.append( '   typedef CPPTL_TYPENAME Functor::%s Arg%d;' %
                                               (self.getFunctorArgTypeName(n),n) )
        self.functor_deduced_type_alias = '\n'.join( functor_deduced_type_alias )
        bind_functor_deduced_types = ['Functor'] + functor_deduced_types + ['BindArg']
        self.bind_functor_deduced_types = '<' + '\n           ,'.join( bind_functor_deduced_types ) + ' >'
        self.multi_bind_template_decl = self.makeTemplateDecl( ['Functor'] + args_template_parameters )
        if is_void:
            self.multi_bind_functor_instantiation = 'Functor0'
            self.multi_bind_cfn_instantiation = self.multi_bind_functor_instantiation
        else:
            self.multi_bind_functor_instantiation = 'Functor0R<CPPTL_TYPENAME Functor::result_type>'
            self.multi_bind_cfn_instantiation = 'Functor0R<Return>'
        self.multi_bind = 'bind%s' % return_suffix.lower()
        self.multi_bind_fn = 'fn0%s' % return_suffix.lower()
        self.multi_functor_generation = self.generateMultiBindFunctor( count,
                                                                       'bind%d' + return_suffix.lower(),
                                                                       'functor' )
        multi_bind_fn_types = [ 'FA%d' % n for n in xrange(1,count+1) ]
        multi_bind_cfn_template_parameters = base_template_parameters + multi_bind_fn_types
        self.multi_bind_cfn_template_decl = self.makeTemplateDecl( multi_bind_cfn_template_parameters )
        self.multi_bind_cfn = 'bind_cfn%s' % return_suffix.lower()
        self.multi_bind_fn_parameter_types = ', '.join( multi_bind_fn_types )
        self.multi_cfn_functor_generation = self.generateMultiBindFunctor( count,
                                                                           'bind%d' + return_suffix.lower(),
                                                                           self.cfn + '( function )' )
        multi_bind_memfn_template_parameters = ['Holder','Object'] + multi_bind_cfn_template_parameters
        self.multi_bind_memfn_template_decl = self.makeTemplateDecl( multi_bind_memfn_template_parameters )
        self.multi_bind_memfn = 'bind_memfn%s' % return_suffix.lower()
        self.multi_memfn_functor_generation = self.generateMultiBindFunctor( count,
                                                                             'bind%d' + return_suffix.lower(),
                                                                             self.memfn + '( holder, member )' )

    def __getitem__( self, key ):
        return getattr( self, key )

    def makeTemplateDecl( self, parameters ):
        if not parameters:
            return ''
        return 'template< class ' + ', class '.join( parameters ) + ' >'

    def makeTemplateInstantiation( self, parameters ):
        if not parameters:
            return ''
        return '< ' + ', '.join( parameters ) + ' >'

    def getFunctorArgTypeNames( self, n ):
        names = [ 'arg%d_type' % n ]
        if n == 1:
            names.append( 'first_argument_type' )
        elif n == 2:
            names.append( 'second_argument_type' )
        return names

    def getFunctorArgTypeName( self, n ):
        return self.getFunctorArgTypeNames(n)[-1]

    def makeArgumentTypedef( self, n ):
        names = self.getFunctorArgTypeNames(n)
        return '\n'.join( [ '   typedef Arg%d %s;' % (n, name) for name in names ] ) + '\n'

    def generateMultiBindFunctor( self, n, bind_fn, bind_args ):
        functor = bind_args
        while n > 0:
            functor = (bind_fn % n) + '( ' + functor + ', a%d' % n + ' )'
            n -= 1
        return functor
            

functors_impl = ''
functors = ''
functor_generators = ''

for argument_count in xrange(0,MAX_ARGUMENT_COUNT+1):
    for is_void in (True,False):
        parameters = GenerationParameters( argument_count, is_void )
        functors_impl += functor_base % parameters
        functors_impl += generic_functor % parameters
        functors_impl += member_functor % parameters
        functors_impl += bind_functor % parameters
        functors += functor % parameters
        functor_generators += generator % parameters
        if argument_count > 0:
            functor_generators += multi_bind_generator  % parameters

final_header = header % locals()

out = file( 'functor.h', 'wt')
out.write( final_header )
out.close()
@


1.5
log
@* fixed bad return statement in void Functor.
@
text
@d50 1
d67 1
@


1.4
log
@* allow up to 5 arguments.
@
text
@d283 1
a283 1
      return impl( %(fn_call)s );
@


1.3
log
@* changed cppunit 2 to use the new functors (cpptl/functor.h). bind_cfn & bind_memfn simplified some of the test code.
@
text
@d3 1
a3 1
MAX_ARGUMENT_COUNT = 2
@


1.2
log
@* simpler implementation of functors.
* complete rewrote of the generator (much easier to maintain)
@
text
@d351 39
d405 2
a406 1
        base_template_parameters.extend( [ 'Arg%d' % n for n in xrange(1,count+1) ] )
d452 26
d492 1
a492 1
    def getFunctorArgTypeName( self, n ):
d498 4
a501 1
        return names[-1]
d504 1
a504 5
        names = [ 'arg%d_type' % n ]
        if n == 1:
            names.append( 'first_argument_type' )
        elif n == 2:
            names.append( 'second_argument_type' )
d507 8
d528 2
@


1.1
log
@* simpler implementation of functors.
* complete rewrote of the generator (much easier to maintain)
@
text
@d3 2
d15 35
d219 29
d327 6
a332 1

d338 1
a338 1
# fn : fnr1
d345 5
d382 4
d392 1
d410 2
d446 1
a446 1
for argument_count in xrange(0,2):
d452 1
@

