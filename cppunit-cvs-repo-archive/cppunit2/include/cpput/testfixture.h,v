head	1.14;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.14
	CPPUNIT2_TG_AFTER_CONSTSTRING:1.6
	CPPUNIT2_TG_BEFORE_CONSTSTRING:1.5
	TG_AFTER_REMOVING_TESTCONTEXT:1.5
	TG_BEFORE_MOVING_ASSERT_TO_TESTINFO:1.5
	TG_BEFORE_REMOVING_TESTCONTEXT:1.5
	arelease:1.1.1.1
	avendor:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2005.11.13.10.12.01;	author blep;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.11.23.23.48;	author blep;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.08.23.25.31;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.08.21.44.54;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.06.22.24.53;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.20.21.06.49;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.28.21.36.19;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.27.14.38.26;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.27.10.15.41;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.17.08.59.05;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.15.08.28.51;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.01.16.12.51;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.27.23.37.21;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.27.20.34.29;	author blep;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.01.27.20.34.29;	author blep;	state Exp;
branches;
next	;


desc
@@


1.14
log
@- renamed include/cpput/assert.h to include/cpput/assertcommon.h. This avoid clash with include <assert.h> in doxygen documentation
- most Impl namespaces are now hidden from documentation using \cond and \endcond.
@
text
@#ifndef CPPUT_TESTFIXTURE_H_INCLUDED
# define CPPUT_TESTFIXTURE_H_INCLUDED

# include <cpput/forwards.h>
# include <cpput/extendeddata.h>
# include <cpput/testcase.h>
# include <cpput/testsuite.h>
# include <cpput/translate.h>
# include <cpptl/typename.h>


namespace CppUT {


/*! \ingroup group_testfixture
 */
class CPPUT_API TestFixture : public CppTL::IntrusiveCount
                            , public TestExtendedDataFactory
{
public:
   virtual ~TestFixture()
   {
   }

   virtual void setUp()
   {
   }

   virtual void tearDown()
   {
   }

   static void addTestWithSpecifics( TestSuite &suite,
                                     const TestPtr &test,
                                     const TestExtendedData &specifics )
   {
      ::CppUT::TestExtendedDataHelper specificHelper( *test );
      specificHelper( specifics );
      suite.add( test );
   }
};



/// \cond implementation_detail
namespace Impl {

   typedef CppTL::IntrusivePtr<TestFixture> TestFixturePtr;

   class CPPUT_API FixtureFactory
   {
   public:
      virtual ~FixtureFactory()
      {
      }

      TestFixturePtr operator()()
      {
         return createNewFixture();
      }

   private:
      virtual TestFixturePtr createNewFixture() =0;
   };


   template<typename FixtureType>
   class FixtureFactoryImpl : public FixtureFactory
   {
   public:
      TestFixturePtr createNewFixture()
      {
         return TestFixturePtr( new FixtureType() );
      }
   };

   template<typename FixtureType>
   class FixtureFactoryWrapper
   {
   public:
      FixtureFactoryWrapper( FixtureFactory &factory )
         : factory_( factory )
      {
      }

      CppTL::IntrusivePtr<FixtureType> operator()()
      {
		  return ::CppTL::staticPointerCast<FixtureType>( factory_() );
      }

   private:
      FixtureFactory &factory_;
   };
} // namespace Impl
/// \endcond implementation_detail


/* Code generated by the helper macros is roughly like this:

class SomeTest : public CppUT::TestFixture
{
public:     // CPPUT_TESTSUITE_BEGIN
   typedef FixtureType CppUT_ThisType;

   static std::string defaultSuiteName()
   {
      return ::CppTL::getTypeName<CppUT_ThisType>( #FixtureType );
   }

   void addTests_( const ::CppUT::TestSuitePtr &suite,
                   ::CppUT::Impl::FixtureFactory &factory_ )
   {
      ::CppUT::Impl::FixtureFactoryWrapper<CppUT_ThisType> fixtureFactory( factory_ );
      ::CppTL::IntrusivePtr<FixtureType> fixture;

      // CPPUT_TESTSUITE_EXTEND (if defined)
      ParentFixtureType::addTests_( suite, factory_ );

      // CPPUT_TEST( testMethod )
      fixture = fixtureFactory();
      suite->add( ::CppUT::makeFixtureTestCase( fixture, 
                                                &FixtureType::testMethod, 
                                                #testMethod ) );

      
   }  // if ended using CPPUT_ABSTRACT_TESTSUITE_END, stop there (suite() is not defined)

   // if ended using CPPUT_TESTSUITE_END, define the static function suite
   static ::CppUT::TestSuitePtr suite()
   {
      ::CppUT::TestSuitePtr testSuite( ::CppUT::makeTestSuite( defaultSuiteName() ) );
      ::CppUT::Impl::FixtureFactoryImpl<CppUT_ThisType> factory;
      addTests_( testSuite, factory );
      return testSuite;
   }
};

*/



# if CPPUT_USE_RTTI_TO_NAME_SUITE
#  define CPPUT_TESTSUITE_NAME_FROM_TYPE( FixtureType )					\
      ::CppTL::getTypeName( ::CppTL::Type<FixtureType>(), #FixtureType )
# else // if CPPUT_USE_RTTI_TO_NAME_SUITE
#  define CPPUT_TESTSUITE_NAME_FROM_TYPE( FixtureType )					\
      std::string( #FixtureType )
# endif // if CPPUT_USE_RTTI_TO_NAME_SUITE



/*! \ingroup group_testfixture
 */
# define CPPUT_TESTSUITE_BEGIN( FixtureType )                                \
public:                                                                      \
   typedef FixtureType CppUT_ThisType;                                       \
                                                                             \
   static std::string defaultSuiteName()                                     \
   {                                                                         \
      return CPPUT_TESTSUITE_NAME_FROM_TYPE( FixtureType );                  \
   }                                                                         \
                                                                             \
   static void addTests_( const ::CppUT::TestSuitePtr &suite,                \
                          ::CppUT::Impl::FixtureFactory &factory_ )          \
   {                                                                         \
      ::CppUT::Impl::FixtureFactoryWrapper<CppUT_ThisType> fixtureFactory(   \
         factory_ );                                                         \
      ::CppTL::IntrusivePtr<FixtureType> fixture
  
/*! \ingroup group_testfixture
 */
# define CPPUT_TESTSUITE_EXTEND( FixtureType, ParentFixtureType )            \
      CPPUT_TESTSUITE_BEGIN( FixtureType );                                  \
      ParentFixtureType::addTests_( suite, factory_ )

/*! \ingroup group_testfixture
 */
# define CPPUT_TESTSUITE_END()                                                \
   }                                                                          \
                                                                              \
   static ::CppUT::TestPtr suite( const std::string &name = std::string("") ) \
   {                                                                          \
      std::string suiteName = name;                                           \
      if ( suiteName.empty() )                                                \
          suiteName = defaultSuiteName();                                     \
      ::CppUT::TestSuitePtr testSuite = ::CppUT::makeTestSuite( suiteName );  \
      ::CppUT::Impl::FixtureFactoryImpl<CppUT_ThisType> factory;              \
      addTests_( testSuite, factory );                                        \
      return ::CppTL::staticPointerCast< ::CppUT::Test >( testSuite );        \
   }

/*! \ingroup group_testfixture
 */
# define CPPUT_ABSTRACT_TESTSUITE_END()                                      \
   }

/*! \ingroup group_testfixture
 */
# define CPPUT_TEST( testMethod )                                            \
      fixture = fixtureFactory();                                            \
      suite->add( ::CppUT::makeFixtureTestCase( fixture,                     \
                   ::CppTL::memfn0( fixture,                                 \
                                    &CppUT_ThisType::testMethod ),           \
                   #testMethod ) )

/*! \ingroup group_testfixture
 */
# define CPPUT_TEST_WITH_SPECIFICS( testMethod, specifics )                  \
      fixture = fixtureFactory();                                            \
      addTestWithSpecifics( *suite,                                          \
                            ::CppUT::makeFixtureTestCase( fixture,           \
                               ::CppTL::memfn0( fixture,                     \
                                  &CppUT_ThisType::testMethod ),             \
                                                          #testMethod ),     \
                            specifics )
         
} // namespace CppUT


#endif // CPPUT_TESTFIXTURE_H_INCLUDED
@


1.13
log
@Rough documentation: placed most function/class/macro in group.
@
text
@d45 1
d95 1
@


1.12
log
@- fixed static registration macro for Registry
- static registration macros must no longer be followed by a semi-colon
  (therefore we get compiler error if registry.h was not included)
- allow registration macros to work with class implenting suite() or suite( const std::string &).
@
text
@d15 2
d150 2
d168 2
d174 2
d190 2
d195 2
d204 2
@


1.11
log
@- changed most interface to use std::string instead of CppTL::ConstString
- CppTL::ConstString is now an implementation detail and is used to store string in objects as it is thread-safe.
@
text
@a49 5
      FixtureFactory()
         : shouldShareFixture_( false )
      {
      }

a53 10
      void setShareFixturePolicy( bool shouldShareFixture )
      {
         shouldShareFixture_ = shouldShareFixture;
      }

      void useNewFixture()
      {
         lastFixture_.reset();
      }

d56 1
a56 3
         if ( !shouldShareFixture_  ||  !lastFixture_ )
            lastFixture_ = createNewFixture();
         return lastFixture_;
a60 4

   private:
      TestFixturePtr lastFixture_;
      bool shouldShareFixture_;
d83 1
a83 11
      void setShareFixturePolicy( bool shouldShareFixture )
      {
         factory_.setShareFixturePolicy( shouldShareFixture );
      }

      void useNewFixture()
      {
         factory_.useNewFixture();
      }

      CPPUT_DEDUCED_TYPENAME CppTL::IntrusivePtr<FixtureType> operator()()
d168 12
a179 11
# define CPPUT_TESTSUITE_END()                                               \
   }                                                                         \
                                                                             \
   static ::CppUT::TestPtr suite( CppTL::ConstString suiteName = std::string("") )  \
   {                                                                         \
      if ( suiteName.empty() )                                               \
          suiteName = defaultSuiteName();                                    \
      ::CppUT::TestSuitePtr testSuite = ::CppUT::makeTestSuite( suiteName.str() ); \
      ::CppUT::Impl::FixtureFactoryImpl<CppUT_ThisType> factory;             \
      addTests_( testSuite, factory );                                       \
      return ::CppTL::staticPointerCast< ::CppUT::Test >( testSuite );       \
a200 23

/*
// still need to find a way to have setUp()/tearDown() called only once
// for all tests.
// TODO: use translate for suite name ?
# define CPPUT_TESTSUITE_SHARE_FIXTURE_BEGIN()                               \
   {                                                                         \
      ::CppUT::TestSuitePtr &parentSuite = suite;                            \
      std::string suiteName = CppUT::translate( "SharedSetUp" );             \
      ::CppUT::TestSuitePtr suite = ::CppUT::makeTestSuite( suiteName );     \
      fixtureFactory.useNewFixture();                                        \
      fixtureFactory.setShareFixturePolicy( true )

# define CPPUT_TESTSUITE_SHARE_FIXTURE_END()                                 \
      parentSuite->add( suite );                                             \
      fixtureFactory.setShareFixturePolicy( false );                         \
   }
*/

# define CPPUT_TESTSUITE_SHARE_FIXTURE()                               \
      fixtureFactory.setShareFixturePolicy( true )


@


1.10
log
@Added possibility to add test to a fixture and set its description and time-out (and other specifics).
@
text
@d132 1
a132 1
   static CppTL::ConstString defaultSuiteName()
d174 1
a174 1
      CppTL::ConstString( #FixtureType )
d183 1
a183 1
   static CppTL::ConstString defaultSuiteName()                                     \
d202 1
a202 1
   static ::CppUT::TestPtr suite( CppTL::ConstString suiteName = CppTL::ConstString("") )  \
d206 1
a206 1
      ::CppUT::TestSuitePtr testSuite = ::CppUT::makeTestSuite( suiteName ); \
d239 1
a239 1
      CppTL::ConstString suiteName = CppUT::translate( "SharedSetUp" );             \
@


1.9
log
@* Added IntrusivePtr, a reference counted smart-pointer
* Changed Test hierarchy and TestFixture to use IntrusivePtr instead of SharedPtr (this allows simple upcasting).
@
text
@d5 1
d14 1
d16 1
d30 9
d222 10
@


1.8
log
@* moved cpput/typehelper.h to cpptl/typename.h
* renamed helper functions: getObjectTypeName(), getTypeName() and demangleTypeInfoName()
* With mingw, typeinfo name is correctly extracted (skip initial digits)
* added automatic detection of the presence of RTTI with msvc.
@
text
@d13 1
a13 1
class CPPUT_API TestFixture
d33 1
a33 1
   typedef CppTL::SharedPtr<TestFixture> TestFixturePtr;
d102 1
a102 1
      CPPUT_DEDUCED_TYPENAME CppTL::SharedPtr<FixtureType> operator()()
d129 1
a129 1
      ::CppTL::SharedPtr<FixtureType> fixture;
d181 1
a181 1
      ::CppTL::SharedPtr<FixtureType> fixture
@


1.7
log
@* changed cppunit 2 to use the new functors (cpptl/functor.h). bind_cfn & bind_memfn simplified some of the test code.
@
text
@d8 1
a8 1
# include <cpput/typehelper.h>
d122 1
a122 1
      return ::CppUT::extractType<CppUT_ThisType>( #FixtureType );
d159 1
a159 1
      ::CppUT::extractType( ::CppTL::Type<FixtureType>(), #FixtureType )
@


1.6
log
@* use CppTL::ConstString instead of std::string for thread-safety
@
text
@d206 2
a207 2
                   ::CppUT::makeMemFn0<CppUT_ThisType>( fixture,             \
                                       &CppUT_ThisType::testMethod ),        \
@


1.5
log
@* moved CppUT::SmartPtr to CppTL::SharedPtr
* moved CppUT::AtomicCounter to CppTL::AtomicCounter and inlined implementation
@
text
@d120 1
a120 1
   static std::string defaultSuiteName()
d162 1
a162 1
      std::string( #FixtureType )
d171 1
a171 1
   static std::string defaultSuiteName()                                     \
d190 1
a190 1
   static ::CppUT::TestPtr suite( std::string suiteName = std::string("") )  \
d217 1
a217 1
      std::string suiteName = CppUT::translate( "SharedSetUp" );             \
@


1.4
log
@* added preprocessor macro to indicate if fixture suite name should be deduced through RTTI or macro expansion: CPPUT_USE_RTTI_TO_NAME_SUITE
* fixed typehelper to work on VC++ 6 (linker bug caused all the templated function to resolve into the same function).
@
text
@d4 1
a4 1
# include <cpput/config.h>
d33 1
a33 1
   typedef SmartPtr<TestFixture> TestFixturePtr;
d102 1
a102 1
      CPPUT_DEDUCED_TYPENAME SmartPtr<FixtureType> operator()()
d104 1
a104 1
		  return ::CppUT::staticPointerCast<FixtureType>( factory_() );
d129 1
a129 1
      ::SmartPtr<FixtureType> fixture;
d181 1
a181 1
      ::CppUT::SmartPtr<FixtureType> fixture
d197 1
a197 1
      return ::CppUT::staticPointerCast< ::CppUT::Test >( testSuite );       \
@


1.3
log
@* added /Za setting to project to force conformance to ANSI C++
* fixed issues related to ANSI C++ conformance
* fixed bug in SliceEnumerator copy constructor & added test
@
text
@d154 13
d173 1
a173 1
      return ::CppUT::extractType<CppUT_ThisType>( #FixtureType );           \
@


1.2
log
@* SmartPtr now subclass boost::shared_ptr to make templated function
  overloading easier.
* Added our own smart pointer implementation
* Added AtomicCounter as implementation detail.
  Can use boost::detail::atomic_counter.
@
text
@d184 1
a184 1
      return ::CppUT::staticPointerCast<::CppUT::Test>( testSuite );         \
d222 1
a222 1
#endif // CPPUT_TESTFIXTURE_H_INCLUDED@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
   typedef SmartPtr<TestFixture>::Ptr TestFixturePtr;
d102 1
a102 1
      CPPUT_DEDUCED_TYPENAME SmartPtr<FixtureType>::Ptr operator()()
d129 1
a129 1
      ::SmartPtr<FixtureType>::Ptr fixture;
d168 1
a168 1
      ::CppUT::SmartPtr<FixtureType>::Ptr fixture
d184 1
a184 1
      return testSuite;                                                      \
@


1.1.1.1
log
@* initial import of cppunit 2
@
text
@@
