head	1.1;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.1;
locks; strict;
comment	@ * @;


1.1
date	2005.12.11.17.49.15;	author blep;	state Exp;
branches;
next	;


desc
@@


1.1
log
@* reorganized code a bit
@
text
@#ifndef CPPUT_OPENTESTADAPTOR_H_INCLUDED
# define CPPUT_OPENTESTADAPTOR_H_INCLUDED

# include <cpput/testcase.h>
# include <opentest/connector.h>
# include <opentest/interfaces.h>

namespace CppUT {

   class OpenTestAdaptor : public OpenTest::TestRunnerInterface
                         , private TestResultUpdater
   {
   public:
      OpenTestAdaptor()
         : currentTestPlanId_( 0 )
      {
      }

      virtual ~OpenTestAdaptor()
      {
      }

      void addTest( const TestPtr &test )
      {
         tests_.push_back( test );
      }

   public: // overridden from TestRunnerInterface

      virtual void getTestDescriptions()
      {
         OpenTest::TestDescriptions descriptions;
         for ( Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it )
         {
            addTestDescriptions( *it, descriptions );
         }
         connector().testDriver().setTestDescriptions( descriptions );
      }

      OpenTest::TestId allocateTestId( const TestPtr &test )
      {
         OpenTest::TestId testId;
         IdsByTest::iterator it = idsByTest_.find( test );
         if ( it == idsByTest_.end() )
         {
            testId = OpenTest::TestId( idsByTest_.size() + 1 );
            idsByTest_.insert( IdsByTest::value_type( test, testId ) );
            testsById_.insert( TestsById::value_type( testId, test ) );
         }
         else
            testId = it->second;
         return testId;
      }

      void setCommonTestDescription( const TestPtr &test,
                                     OpenTest::TestId testId,
                                     OpenTest::TestDescriptionCommon &description )
      {
         description.name_ = test->name();
         description.description_ = test->description();
         // time-out
         // specifics
      }

      void addTestDescriptions( const TestPtr &test, 
                                OpenTest::TestDescriptions &descriptions )
      {
         OpenTest::TestId testId = allocateTestId( test );

         if ( test->isTestSuite() )
         {
            OpenTest::TestSuiteDescription suiteDescription;
            setCommonTestDescription( test, testId, suiteDescription );
            const AbstractTestSuite *suite = static_cast<AbstractTestSuite*>( test.get() );
            for ( int index = 0; index < suite->testCount(); ++index )
            {
               TestPtr childTest = suite->testAt(index);
               addTestDescriptions( childTest, descriptions );
               suiteDescription.children_.push_back( allocateTestId( childTest ) );
            }
            descriptions.testSuites_.insert( OpenTest::TestDescriptions::TestSuites::value_type( testId, suiteDescription ) );
         }
         else
         {
            OpenTest::TestCaseDescription testCaseDescription;
            setCommonTestDescription( test, testId, testCaseDescription );
            descriptions.testCases_.insert( OpenTest::TestDescriptions::TestCases::value_type( testId, testCaseDescription ) );
         }
      }

      virtual void getTestPlans()
      {
         OpenTest::TestPlans plans;
         for ( TestsById::iterator it = testsById_.begin(); it != testsById_.end(); ++it )
         {
            if ( it->second->isTestCase() )
            {
               OpenTest::TestPlan plan;
               plan.testCase_ = it->first;
               plans.testPlans_.push_back( plan );
            }
         }
         connector().testDriver().setDefaultTestPlans( plans );
      }

      virtual void runTests( const OpenTest::TestPlans &plans )
      {
         TestInfo::threadInstance().setTestResultUpdater( *this );
         for ( OpenTest::TestPlans::Plans::const_iterator it = plans.testPlans_.begin(); it != plans.testPlans_.end(); ++it )
         {
            const OpenTest::TestPlan &plan = *it;
            TestsById::const_iterator itTest = testsById_.find( plan.testCase_ );
            if ( itTest != testsById_.end() )
            {
               currentTestPlanId_ = OpenTest::TestPlanId( it - plans.testPlans_.begin() );
               TestPtr test = itTest->second;
               if ( test->isTestCase() )
               {
                  AbstractTestCase &testCase = static_cast<AbstractTestCase &>(*test);
                  connector().testDriver().startTesting( currentTestPlanId_ );
                  testCase.runTest();
                  publishTestResult();
               }
            }
         }
         TestInfo::threadInstance().removeTestResultUpdater();
      }

      void publishTestResult()
      {
         OpenTest::ResultStatus status;
         const TestStatus &actualStatus = TestInfo::threadInstance().testStatus();
         switch ( actualStatus.status() )
         {
         case TestStatus::passed:
            status.status_ = "passed";
            break;
         case TestStatus::failed:
            status.status_ = "failed";
            break;
         case TestStatus::skipped:
            status.status_ = "skipped";
            break;
         default:
            CPPTL_DEBUG_ASSERT_UNREACHABLE;
         }
         status.statistics_["assertionCount"] = actualStatus.assertionCount();
         status.statistics_["failedAssertionCount"] = actualStatus.failedAssertionCount();
         status.statistics_["ignoredFailureCount"] = actualStatus.ignoredFailureCount();
         connector().testDriver().setTestResult( currentTestPlanId_, status );
      }

      virtual void stopTests()
      {
      }

   private: // overridden from TestResultUpdater
      virtual void addResultLog( const Json::Value &log )
      {
         OpenTest::ResultLog result;
         result.log_ = log;
         connector().testDriver().addResultLog( currentTestPlanId_, result );
      }

      virtual void addResultAssertion( const Assertion &assertion )
      {
         OpenTest::ResultAssertion result;
         result.assertionType_ = (assertion.kind() == Assertion::fault) ? "fault" 
                                                                        : "assertion";
         result.assertionFormat_ = "generic";
         result.message_ = assertion.messages().toString();
         result.specific_ = assertion.testData();
         result.isIgnoredFailure_ = assertion.isIgnoredFailure();
         connector().testDriver().addResultAssertion( currentTestPlanId_, result );
      }

   private:
      typedef std::map<OpenTest::TestId,TestPtr> TestsById;
      typedef std::map<TestPtr,OpenTest::TestId> IdsByTest;
      typedef std::deque<TestPtr> Tests;
      Tests tests_;
      OpenTest::TestPlanId currentTestPlanId_;
      TestsById testsById_;
      IdsByTest idsByTest_;
   };
} // namespace CppUT


#endif // CPPUT_OPENTESTADAPTOR_H_INCLUDED
@
