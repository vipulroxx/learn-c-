head	1.2;
access;
symbols
	CPPUNIT2_TG_BEFORE_NEW_ASSERTION:1.2;
locks; strict;
comment	@// @;


1.2
date	2005.12.11.17.49.14;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.11.17.16.08;	author blep;	state Exp;
branches;
next	;


desc
@@


1.2
log
@* reorganized code a bit
@
text
@#include <examples/common/examplecommon.h>
#include <cpput/opentestadaptor.h>
#include <opentest/texttestdriver.h>

// Checking assertion do not abort the test uppon failure:
// all the failing assertions below will be reported by the test framework
static void testBasicCheckingAssertion()
{
   CPPUT_CHECK( 1 == 2, "1 is not equal to 2..."  );
   CPPUT_CHECK_EXPR( 1 + 2 == 4 );
   CPPUT_CHECK_FALSE( 1 == 1, "1 is equal to 1..."  );
   CPPUT_CHECK_EXPR_FALSE( 1 + 1 == 2 );
   CPPUT_CHECK_EQUAL( 1, 2 );
   CPPUT_CHECK_NOT_EQUAL( 34, 34 );
}

static void testLogDemo()
{
   for ( int index =0; index < 5; ++index )
   {
      CppUT::log( "index is " + CppTL::toString(index) );
      CPPUT_CHECK_EXPR( index % 2 == 0 );
   }
}



int main( int argc, const char *argv[] )
{
   CppUT::TestSuitePtr allSuite = CppUT::makeTestSuite( "All tests" );
   allSuite->add( CppUT::makeTestCase( CppTL::cfn0( &testBasicCheckingAssertion ), 
                                       "testBasicCheckingAssertion" ) );
   allSuite->add( CppUT::makeTestCase( CppTL::cfn0( &testLogDemo ), 
                                       "testLogDemo" ) );
   CppUT::OpenTestAdaptor runner;
   runner.addTest( allSuite.get() );

   OpenTest::TextTestDriver driver( argc, argv );
   driver.addTestRunner( runner );
   return driver.runTests();
}
@


1.1
log
@* rough sketch of a working OpenTest driver with CppUT adaptor for TestRunner.
@
text
@d2 2
a3 305
#include <cpput/testcase.h>
#include <opentest/connector.h>
#include <opentest/interfaces.h>
#include <stdio.h>

namespace CppUT {

   class CppUTTestRuner : public OpenTest::TestRunnerInterface
                        , private TestResultUpdater
   {
   public:
      CppUTTestRuner()
         : currentTestPlanId_( 0 )
      {
      }

      void addTest( const TestPtr &test )
      {
         tests_.push_back( test );
      }

   public: // overridden from TestRunnerInterface
      virtual ~CppUTTestRuner()
      {
      }

      virtual void getTestDescriptions()
      {
         OpenTest::TestDescriptions descriptions;
         for ( Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it )
         {
            addTestDescriptions( *it, descriptions );
         }
         connector().testDriver().setTestDescriptions( descriptions );
      }

      OpenTest::TestId allocateTestId( const TestPtr &test )
      {
         OpenTest::TestId testId;
         IdsByTest::iterator it = idsByTest_.find( test );
         if ( it == idsByTest_.end() )
         {
            testId = OpenTest::TestId( idsByTest_.size() + 1 );
            idsByTest_.insert( IdsByTest::value_type( test, testId ) );
            testsById_.insert( TestsById::value_type( testId, test ) );
         }
         else
            testId = it->second;
         return testId;
      }

      void setCommonTestDescription( const TestPtr &test,
                                     OpenTest::TestId testId,
                                     OpenTest::TestDescriptionCommon &description )
      {
         description.name_ = test->name();
         description.description_ = test->description();
         // time-out
         // specifics
      }

      void addTestDescriptions( const TestPtr &test, 
                                OpenTest::TestDescriptions &descriptions )
      {
         OpenTest::TestId testId = allocateTestId( test );

         if ( test->isTestSuite() )
         {
            OpenTest::TestSuiteDescription suiteDescription;
            setCommonTestDescription( test, testId, suiteDescription );
            const AbstractTestSuite *suite = static_cast<AbstractTestSuite*>( test.get() );
            for ( int index = 0; index < suite->testCount(); ++index )
            {
               TestPtr childTest = suite->testAt(index);
               addTestDescriptions( childTest, descriptions );
               suiteDescription.children_.push_back( allocateTestId( childTest ) );
            }
            descriptions.testSuites_.insert( OpenTest::TestDescriptions::TestSuites::value_type( testId, suiteDescription ) );
         }
         else
         {
            OpenTest::TestCaseDescription testCaseDescription;
            setCommonTestDescription( test, testId, testCaseDescription );
            descriptions.testCases_.insert( OpenTest::TestDescriptions::TestCases::value_type( testId, testCaseDescription ) );
         }
      }

      virtual void getTestPlans()
      {
         OpenTest::TestPlans plans;
         for ( TestsById::iterator it = testsById_.begin(); it != testsById_.end(); ++it )
         {
            if ( it->second->isTestCase() )
            {
               OpenTest::TestPlan plan;
               plan.testCase_ = it->first;
               plans.testPlans_.push_back( plan );
            }
         }
         connector().testDriver().setDefaultTestPlans( plans );
      }

      virtual void runTests( const OpenTest::TestPlans &plans )
      {
         TestInfo::threadInstance().setTestResultUpdater( *this );
         for ( OpenTest::TestPlans::Plans::const_iterator it = plans.testPlans_.begin(); it != plans.testPlans_.end(); ++it )
         {
            const OpenTest::TestPlan &plan = *it;
            TestsById::const_iterator itTest = testsById_.find( plan.testCase_ );
            if ( itTest != testsById_.end() )
            {
               currentTestPlanId_ = OpenTest::TestPlanId( it - plans.testPlans_.begin() );
               TestPtr test = itTest->second;
               if ( test->isTestCase() )
               {
                  AbstractTestCase &testCase = static_cast<AbstractTestCase &>(*test);
                  connector().testDriver().startTesting( currentTestPlanId_ );
                  testCase.runTest();
                  publishTestResult();
               }
            }
         }
         TestInfo::threadInstance().removeTestResultUpdater();
      }

      void publishTestResult()
      {
         OpenTest::ResultStatus status;
         const TestStatus &actualStatus = TestInfo::threadInstance().testStatus();
         switch ( actualStatus.status() )
         {
         case TestStatus::passed:
            status.status_ = "passed";
            break;
         case TestStatus::failed:
            status.status_ = "failed";
            break;
         case TestStatus::skipped:
            status.status_ = "skipped";
            break;
         default:
            CPPTL_DEBUG_ASSERT_UNREACHABLE;
         }
         status.statistics_["assertionCount"] = actualStatus.assertionCount();
         status.statistics_["failedAssertionCount"] = actualStatus.failedAssertionCount();
         status.statistics_["ignoredFailureCount"] = actualStatus.ignoredFailureCount();
         connector().testDriver().setTestResult( currentTestPlanId_, status );
      }

      virtual void stopTests()
      {
      }

   private: // overridden from TestResultUpdater
      virtual void addResultLog( const Json::Value &log )
      {
         OpenTest::ResultLog result;
         result.log_ = log;
         connector().testDriver().addResultLog( currentTestPlanId_, result );
      }

      virtual void addResultAssertion( const Assertion &assertion )
      {
         OpenTest::ResultAssertion result;
         result.assertionType_ = (assertion.kind() == Assertion::fault) ? "fault" 
                                                                        : "assertion";
         result.assertionFormat_ = "generic";
         result.message_ = assertion.messages().toString();
         result.specific_ = assertion.testData();
         result.isIgnoredFailure_ = assertion.isIgnoredFailure();
         connector().testDriver().addResultAssertion( currentTestPlanId_, result );
      }

   private:
      typedef std::map<OpenTest::TestId,TestPtr> TestsById;
      typedef std::map<TestPtr,OpenTest::TestId> IdsByTest;
      typedef std::deque<TestPtr> Tests;
      Tests tests_;
      OpenTest::TestPlanId currentTestPlanId_;
      TestsById testsById_;
      IdsByTest idsByTest_;
   };
} // namespace CppUT


namespace OpenTest
{

   typedef CppTL::IntrusivePtr<OpenTest::TestRunnerInterface> TestRunnerInterfacePtr;

   class TestDriver : private TestDriverInterface
   {
   public:
      TestDriver( int argc, const char *argv[] )
      {
      }

      virtual ~TestDriver()
      {
      }

      void addTestRunner( TestRunnerInterface &testRunner )
      {
         addConnector( new DirectConnector( testRunner, *this ) );
      }

      void addConnector( const ConnectorPtr &connector )
      {
         connectors_.push_back( connector );
      }

      void runTests()
      {
         for ( Connectors::iterator it = connectors_.begin();
               it != connectors_.end();
               ++it )
         {
            Connector &connector = **it;
            if ( connector.status().status_ != connectionEstablished )
               connector.establishConnection();
         }

         for ( Connectors::iterator it = connectors_.begin();
               it != connectors_.end();
               ++it )
         {
            Connector &connector = **it;
            if ( connector.status().status_ == connectionEstablished )
            {
               connector.testRunner().getTestDescriptions();
               connector.testRunner().getTestPlans();
               connector.testRunner().runTests(plans_);
            }
         }
      }

   private: // overridden from TestDriverInterface
      virtual void setTestDescriptions( const TestDescriptions &tests )
      {
         descriptions_ = tests;
      }

      virtual void setDefaultTestPlans( const TestPlans &plans )
      {
         plans_ = plans;
      }

      virtual void startTesting( TestPlanId testPlan )
      {
         printf( "Start testing: %s\n", getTestCaseDesc( testPlan ).name_.c_str() );
      }

      virtual void addResultLog( TestPlanId testPlan, 
                                 const ResultLog &log )
      {
         printf( "Log for %s:\n", 
                 getTestCaseDesc( testPlan ).name_.c_str() );
      }

      virtual void addResultAssertion( TestPlanId testPlan, 
                                       const ResultAssertion &assertion )
      {
         printf( "- Assertion for %s:\n"
                 "Type:%s\n"
                 "Message:\n%s\n", 
                 getTestCaseDesc( testPlan ).name_.c_str(),
                 assertion.assertionType_.c_str(),
                 assertion.message_.c_str() );
      }

      virtual void setResultInputActualOutput( TestPlanId testPlan, 
                                               const ResultInputOutput &output )
      {
      }

      virtual void setTestResult( TestPlanId testPlan, 
                                  const ResultStatus &status )
      {
         printf( "Result for %s:\n%s\n", 
                 getTestCaseDesc( testPlan ).name_.c_str(),
                 status.status_.c_str() );
      }

      virtual void testPlanDone( TestPlanId id )
      {
      }

   private:
      OpenTest::TestCaseDescription &getTestCaseDesc( TestPlanId testPlan )
      {
         TestId testId = plans_.testPlans_.at( testPlan ).testCase_;
         TestDescriptions::TestCases::iterator it = descriptions_.testCases_.find( testId );
         if ( it == descriptions_.testCases_.end() )
            throw std::runtime_error( "Invalid test plan" );
         return it->second;
      }

      typedef std::deque<ConnectorPtr> Connectors;
      Connectors connectors_;
      OpenTest::TestPlans plans_;
      OpenTest::TestDescriptions descriptions_;
   };
};


d17 9
d33 3
a35 1
   CppUT::CppUTTestRuner runner;
d38 1
a38 1
   OpenTest::TestDriver driver( argc, argv );
@

