head	1.15;
access;
symbols;
locks; strict;
comment	@// @;


1.15
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.14;

1.14
date	2006.03.10.21.28.38;	author blep;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.01.18.26.17;	author blep;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.09.22.59.09;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.08.20.25.49;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.07.22.43.08;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.06.07.31.42;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.04.08.12.33;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.02.20.27.36;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.02.09.19.06;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.01.20.32.04;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.01.08.19.36;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.30.21.49.26;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.26.19.41.15;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.24.08.23.50;	author blep;	state Exp;
branches;
next	;


desc
@@


1.15
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#include <opentest/serializer.h>
#include <float.h>
#include <stdio.h>

// @@todo Packets : should assumes packets end at the end of the current message when reading...
// @@todo Packets::discardFirstMessage(), needs to actually free some memory...


namespace OpenTest {

/*
0x20:  0x21:! 0x22:" 0x23:# 0x24:$ 0x25:% 0x26:& 0x27:' 0x28:( 0x29:) 0x2a:* 0x2b:+ 0x2c:, 0x2d:- 0x2e:. 0x2f:/ 
0x30:0 0x31:1 0x32:2 0x33:3 0x34:4 0x35:5 0x36:6 0x37:7 0x38:8 0x39:9 0x3a:: 0x3b:; 0x3c:< 0x3d:= 0x3e:> 0x3f:? 
0x40:@@ 0x41:A 0x42:B 0x43:C 0x44:D 0x45:E 0x46:F 0x47:G 0x48:H 0x49:I 0x4a:J 0x4b:K 0x4c:L 0x4d:M 0x4e:N 0x4f:O 
0x50:P 0x51:Q 0x52:R 0x53:S 0x54:T 0x55:U 0x56:V 0x57:W 0x58:X 0x59:Y 0x5a:Z 0x5b:[ 0x5c:\ 0x5d:] 0x5e:^ 0x5f:_ 
0x60:` 0x61:a 0x62:b 0x63:c 0x64:d 0x65:e 0x66:f 0x67:g 0x68:h 0x69:i 0x6a:j 0x6b:k 0x6c:l 0x6d:m 0x6e:n 0x6f:o 
0x70:p 0x71:q 0x72:r 0x73:s 0x74:t 0x75:u 0x76:v 0x77:w 0x78:x 0x79:y 0x7a:z 0x7b:{ 0x7c:| 0x7d:} 0x7e:~ 0x7f:

Encoding:
0x20-0x30: stream control character
0x30-0xff: stream content character

Notes: encoding real number that way is too complicated. It also does not handle +-inf and nan.

 */

enum ControlChar
{
   ccBooleanTrue = 0x21,            // '!'
   ccString = 0x22,                 // '"'
   ccBooleanFalse = 0x23,           // '#'
   ccLookUpDictionnaryEntry = 0x24, // '$'
   ccEndBuffer = 0x25,              // '%'
   ccNoneValue = 0x26,              // '&'
   ccNewDictionnaryEntry = 0x27,    // "'"
   ccArrayValue = 0x28,             // '('
   ccObjectValueEnd = 0x29,         // ')'
   ccPositiveReal = 0x2a,           // '*'
   ccPositiveInteger = 0x2b,        // '+'
   ccEmptyObjectValue = 0x2c,       // ','
   ccNegativeInteger = 0x2d,        // '-'
   ccRealDot = 0x2e,                // '.'
   ccNegativeReal = 0x2f,           // '/'
   ccIntegerZero = 0x30,            // integer shift for encoding
   ccIntegerBaseShift = 6,          // power of 2 for encoding base (0x40 = 1 << 6)
   ccRealWithinPlusSign = 0x5e,     // '^'
   ccRealWithinMinusSign = 0x5f,    // '_'
};

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Packets
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

Packets::Packets( Pos defaultPacketSize )
   : packetsHead_( 0 )
   , defaultPacketSize_( defaultPacketSize )
{
}

Packets::~Packets()
{
   Packet *current = packetsHead_;
   while ( current )
   {
      Packet *toDelete = current;
      current = current->next_;
      delete toDelete;
   }
}


void 
Packets::beginWriteMessage()
{
   appendPacketIfFull();
   MessagePacket message;
   message.position_ = writePos_;
   message.length_ = 0;
   messages_.push_back( message );
}


void 
Packets::endWriteMessage()
{
   CPPTL_ASSERT_MESSAGE( !messages_.empty()  &&  messages_.back().length_ == 0, 
                         "No message started." );
   messages_.back().length_ = distance( messages_.back().position_, writePos_ );
}


bool 
Packets::hasPendingMessage() const
{
   return !messages_.empty();
}


Packets::Pos 
Packets::getFirstMessageLength()
{
   CPPTL_ASSERT_MESSAGE( !messages_.empty(), "No message available" );
   CPPTL_ASSERT_MESSAGE( messages_.front().length_ != 0, "Message not completly serialized." );
   return messages_.front().length_;
}


void
Packets::discardFirstMessage()
{
   messages_.pop_front();
   
   //Packet *current = packetsHead_;
   //while ( current != writePos_.packet_ )
   //{
   //   Packet *toDelete = current;
   //   current = current->next_;
   //   CPPTL_ASSERT_MESSAGE( toDelete != readPos_.packet_, 
   //                         "Deleting packets used for serialization." );
   //   delete toDelete;
   //}
   //packetsHead_ = current;
}


Packets::Pos
Packets::read( void *dest, 
               Pos availableLength )
{
   return read( readPos_, static_cast<Byte *>( dest ), availableLength );
}


Packets::Byte
Packets::readByte()
{
   if ( readPos_ )
   {
      if ( readPos_.currentData_ == readPos_.packet_->endInitialized_ )
      {
         if ( readPos_.packet_->next_ == 0 )
            return ccEndBuffer;
         readPos_.seekToNextPacket();
      }
      return *(readPos_.currentData_++);
   }
   return ccEndBuffer;
}

void 
Packets::unreadLastByte()
{
   CPPTL_ASSERT_MESSAGE( readPos_, "No byte to unget" );
   if ( readPos_.currentData_ > readPos_.packet_->begin_ )
      --readPos_.currentData_;
   else
      readPos_.seekBeforeEndOfPreviousPacket();
}

void 
Packets::write( const void *buffer, 
                Pos length )
{
   write( writePos_, static_cast<const Byte *>( buffer ), length );
}

void 
Packets::writeByte( Byte byte )
{
   if ( writePos_  &&  writePos_.currentData_ != writePos_.packet_->end_ )
   {
      *writePos_.currentData_++ = byte;
      writePos_.packet_->endInitialized_ = writePos_.currentData_;
   }
   else
      write( writePos_, &byte, 1 );
}


void 
Packets::appendPacketIfFull()
{
   if ( !writePos_  ||  writePos_.currentData_ == writePos_.packet_->end_ )
   {
      Packet *packet = new Packet( defaultPacketSize_, writePos_.packet_ );
      if ( !packetsHead_ )
         packetsHead_ = packet;
      writePos_ = PacketPos( packet );
      if ( !readPos_ )
         readPos_ = writePos_;
   }
}


Packets::Pos 
Packets::distance( const PacketPos &begin, 
                   const PacketPos &end ) const
{
   CPPTL_ASSERT_MESSAGE( begin && end, "can only compute distance() of valid PacketPos" );

   Pos dist = 0;
   if ( begin.packet_ != end.packet_ )
   {
      dist += begin.availableUntilEnd();
      for ( Packet *current = begin.packet_->next_; current != end.packet_; current = current->next_ )
         dist += current->length();
      dist += end.offset();
   }
   else
   {
      dist += end.currentData_ - begin.currentData_;
   }
   return dist;
}


void 
Packets::write( PacketPos &pos, const Byte *data, Pos length )
{
   if ( length == 0 )
      return;

   if ( !pos )
      appendPacketIfFull();

   Pos writeLength  = CPPTL_MIN( pos.availableForWriting(), length );
   memcpy( pos.currentData_, data, writeLength );
   length -= writeLength;
   pos.currentData_ += writeLength;
   pos.packet_->endInitialized_ += writeLength;
   while ( length > 0 )
   {
      data += writeLength;
      CPPTL_ASSERT_MESSAGE( pos.currenData_ == pos.packet_->end_, 
                            "Should be at the end of the current packet" );
      appendPacketIfFull();
      writeLength  = CPPTL_MIN( pos.packet_->length(), length );
      memcpy( pos.packet_->begin_, data, writeLength );
      length -= writeLength;
      pos.packet_->endInitialized_ += writeLength;
      pos.currentData_ = pos.packet_->offset( writeLength );
   }
}


Packets::Pos 
Packets::read( PacketPos &pos, Byte *data, Pos length )
{
   if ( !pos )
      return 0;

   Pos initialLength = length;
   while ( length > 0 )
   {
      pos.seekToNextPacketIfAtEnd();
      Pos readLength = CPPTL_MIN( length, pos.availableForReading() );
      if ( readLength == 0 )
         break;
      memcpy( data, pos.currentData_, readLength );
      length -= readLength;
      pos.currentData_ += readLength;
      data += readLength;
   }
   return initialLength - length;
}




// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class Stream
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////



Stream::Stream() 
   : error_( 0 )
{
}

Stream::~Stream() 
{
}


Packets &
Stream::packets()
{
   return packets_;
}


bool 
Stream::inError() const
{
   return error_ != 0;
}

Stream &
Stream::setError( const char *errorMessage )
{
   if ( !error_ )
      error_ = errorMessage;
   return *this;
}


Stream::Byte 
Stream::readNextByte()
{
   return packets_.readByte();
}

void 
Stream::ungetLastByte()
{
   packets_.unreadLastByte();
}

void 
Stream::read( void *buffer, unsigned int length )
{
   if ( packets_.read( buffer, length ) != length )
      setError( "Attempted to read beyond buffer end." );
}


void 
Stream::write( Byte byte )
{
   packets_.writeByte( byte );
}


void 
Stream::write( const void *buffer, unsigned int length )
{
   packets_.write( buffer, length );
}


Stream &
Stream::operator <<( bool value )
{
   write( value ? ccBooleanTrue : ccBooleanFalse );
   return *this;
}

#ifndef CPPTL_NO_INT64
Stream &
Stream::operator <<( int value )
{
   return *this << LargestInt( value );
}


Stream &
Stream::operator <<( unsigned int value )
{
   doSerializeInteger( ccPositiveInteger, value );
   return *this;
}
#endif

Stream &
Stream::operator <<( LargestInt value )
{
   if ( value >= 0 )
      doSerializeInteger( ccPositiveInteger, value );
   else
      doSerializeInteger( ccNegativeInteger, -value );
   return *this;
}

Stream &
Stream::operator <<( LargestUnsignedInt value )
{
   doSerializeInteger( ccPositiveInteger, value );
   return *this;
}

void 
Stream::doSerializeInteger( Byte kind, 
                            LargestUnsignedInt value )
{
   Byte buffer[ (sizeof(value)*8 + ccIntegerBaseShift - 1) / ccIntegerBaseShift ];
   Byte *current = buffer + sizeof(buffer);
   do
   {
      Byte reminder = Byte(value & ((1 << ccIntegerBaseShift) - 1));
      *--current = reminder + ccIntegerZero;
      value >>= ccIntegerBaseShift;
   }
   while ( value != 0 );
   
   CPPTL_ASSERT_MESSAGE( current >= &buffer[0], "buffer underrun" );

   write( kind );
   write( current, buffer + sizeof(buffer) - current );
}


Stream &
Stream::operator <<( double value )
{
#ifdef DBL_DIG
   const int precision = DBL_DIG;
#else
   const int precision = 15;
#endif  // #ifdef DBL_DIG
   char buffer[precision * 2 + 32];
#ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
   int length = sprintf_s(buffer, sizeof(buffer), "%.*g", precision, value); 
#else	
   int length = sprintf(buffer, "%.*g", precision, value);
#endif
   if ( length == 0)
      return setError( "Failed to serialize double value (empty string)" );
   char *current = &buffer[0];
   char *end = buffer + length;
   for ( ; current != end; ++current )
   {
      if ( *current == ccPositiveInteger )
         *current = ccRealWithinPlusSign;
      else if ( *current == ccNegativeInteger )
         *current = ccRealWithinMinusSign;
      else if ( *current == ccRealDot )
      { // do nothing
      }
      else
      {
          CPPTL_ASSERT_MESSAGE( (Byte)*current >= ccIntegerZero,
                                "Real number conversion produced stream control characters!" );
      }
   }
   if ( buffer[0] == ccRealWithinMinusSign )
   {
      write( ccNegativeReal );
      write( buffer + 1, length-1 );
   }
   else
   {
      write( ccPositiveReal );
      if ( buffer[0] == ccRealWithinPlusSign )
         write( buffer + 1, length-1 );
      else
         write( buffer, length );
   }
   return *this;
}


Stream &
Stream::operator <<( const String &str )
{
   doSerializeInteger( ccString, str.length() );
   write( ccString );
   write( str.c_str(), str.length() );
   return *this;
}


void
Stream::saveDictionnaryEntry( const String &str )
{
   IndexesByString::const_iterator it = indexesByString_.find( str );
   if ( it == indexesByString_.end() )
   {
      unsigned int index = indexesByString_.size();
      indexesByString_[ str ] = index;
      doSerializeInteger( ccNewDictionnaryEntry, str.length() );
      write( ccString );
      write( str.c_str(), str.length() );
   }
   else
   {
      doSerializeInteger( ccLookUpDictionnaryEntry, it->second );
   }
}


void 
Stream::doUnserializeInteger( LargestUnsignedInt &value )
{
   value = 0;
   Byte digit;
   while ( (digit = readNextByte()) >= ccIntegerZero )
   {
      // if ( value >= maxInt )   // should we detect overflow ?
      value <<= ccIntegerBaseShift;
      value |= LargestUnsignedInt(digit-ccIntegerZero);
   }

   ungetLastByte();
}


Stream &
Stream::operator >>( bool &value )
{
   if ( inError() )
      return *this;

   Byte control = readNextByte();
   if ( control == ccBooleanTrue )
      value = true;
   else if ( control == ccBooleanFalse )
      value = false;
   else
      setError( "Boolean expected" );
   return *this;
}

#ifndef CPPTL_NO_INT64
Stream &
Stream::operator >>( int &value )
{
   LargestInt temp;
   *this >> temp;
   value = int(temp);
   return *this;
}


Stream &
Stream::operator >>( unsigned int &value )
{
   LargestUnsignedInt temp;
   *this >> temp;
   value = (unsigned int)temp;
   return *this;
}
#endif

Stream &
Stream::operator >>( LargestInt &value )
{
   if ( inError() )
      return *this;

   Byte control = readNextByte();
   LargestUnsignedInt unsignedValue;
   if ( control == ccPositiveInteger )
   {
      doUnserializeInteger( unsignedValue );
      value = unsignedValue;
   }
   else if ( control == ccNegativeInteger )
   {
      doUnserializeInteger( unsignedValue );
      value = -LargestInt(unsignedValue);
   }
   else
      setError( "Integer expected" );
   return *this;
}


Stream &
Stream::operator >>( LargestUnsignedInt &value )
{
   if ( inError() )
      return *this;

   Byte control = readNextByte();
   if ( control == ccPositiveInteger )
      doUnserializeInteger( value );
   else
      setError( "Unsigned integer expected" );
   return *this;
}

Stream &
Stream::operator >>( double &value )
{
   if ( inError() )
      return *this;

   CppTL::StringBuffer buffer;
   Byte control = readNextByte();
   if ( control == ccNegativeReal )
      buffer += "-";
   else if ( control != ccPositiveReal )
      return setError( "Unsigned integer expected" );

   char digits[2];
   digits[1] = 0;
   while ( true )
   {
      Byte digit = readNextByte();
      if ( digit == ccRealWithinPlusSign )
         buffer += "+";
      else if ( digit == ccRealWithinMinusSign )
         buffer += "-";
      else if ( digit == ccRealDot  ||  digit >= ccIntegerZero )
      {
         digits[0] = digit;
         buffer += digits;
      }
      else  // control char
         break;
   }
   ungetLastByte();

   char *actualEnd = 0;
   value = strtod( buffer.c_str(), &actualEnd );
   if ( actualEnd != buffer.c_str() + buffer.length() )
      setError( "Unable to unserialize real number correctly." );

   return *this;
}


Stream &
Stream::operator >>( String &str )
{
   if ( inError() )
      return *this;

   Byte control = readNextByte();
   if ( control == ccString )
      readString( str );
   else
      setError( "String expected" );
   return *this;
}


void 
Stream::readDictionnaryEntry ( Byte control,
                               String &str )
{
   if ( control == ccLookUpDictionnaryEntry )
   {
      LargestUnsignedInt index;
      doUnserializeInteger( index );
      if ( index >= stringsByIndex_.size() )
         setError( "Invalid dictionnary look-up index" );
      else
         str = stringsByIndex_[index];
   }
   else if ( control == ccNewDictionnaryEntry )
   {
      readString( str );
      stringsByIndex_.push_back( str );
   }
   else
      setError( "Dictionnary string expected" );
}


void 
Stream::readString( String &str )
{
   LargestUnsignedInt length;
   doUnserializeInteger( length );
   Byte control = readNextByte();
   if ( control != ccString )
      setError( "Expected string." );
   else if ( length <= sizeof(stringBuffer_) )
   {
      read( stringBuffer_, length );
      str = String( stringBuffer_, stringBuffer_ + length );
   }
   else
   {
      CppTL::StringBuffer largeBuffer;
      largeBuffer.truncate( length );
      read( &largeBuffer[0], length );
      str = String( largeBuffer );
   }
}


bool 
Stream::isNamedPropertyControl( Byte control )
{
   return control == ccLookUpDictionnaryEntry  
          ||  control == ccNewDictionnaryEntry;
}


void 
Stream::serializeArrayValue( const Value &value )
{
   LargestUnsignedInt length = value.size();
   doSerializeInteger( ccArrayValue, length );
   for ( LargestUnsignedInt index = 0; index < length; ++index )
      *this << value[index];
}

void 
Stream::serializeObjectValue( const Value &value )
{
   Value::Members names = value.getMemberNames();  // @@todo implements a more efficient iteration over members
   if ( names.empty() )
   {
      write( ccEmptyObjectValue );
   }
   else
   {
      Value::Members::const_iterator it = names.begin();
      Value::Members::const_iterator itEnd = names.end();
      for ( ; it != itEnd; ++it )
      {
         saveDictionnaryEntry( *it );
         *this << value[*it];
      }
      write( ccObjectValueEnd );
   }
}


void 
Stream::unserializeArrayValue( Value &value )
{
   value = Value( Json::arrayValue );
   LargestUnsignedInt length;
   doUnserializeInteger( length );
   for ( LargestUnsignedInt index = 0; index < length; ++index )
      *this >> value[index];
}


void 
Stream::unserializeObjectValue( Byte control,
                                Value &value )
{
   value = Value( Json::objectValue );
   do
   {
      String name;
      readDictionnaryEntry( control, name );
      *this >> value[ name.c_str() ];
      control = readNextByte();
   }
   while ( isNamedPropertyControl(control) );
   if ( control != ccObjectValueEnd )
      setError( "Unexpected end of named property list." );
}


Stream &
Stream::operator <<( const Value &value )
{
   switch ( value.type() )
   {
   case Json::nullValue:
      write( ccNoneValue );
      break;
   case Json::booleanValue:
      *this << value.asBool();
      break;
#ifndef CPPTL_NO_INT64
   case Json::intValue:
      *this << value.asInt();
      break;
   case Json::uintValue:
      *this << value.asUInt();
      break;
#else
   case Json::intValue:
      *this << value.asInt();
      break;
   case Json::uintValue:
      *this << value.asUInt();
      break;
#endif
   case Json::realValue:
      *this << value.asDouble();
      break;
   case Json::stringValue:
      *this << String( value.asString().c_str() );
      break;
   case Json::arrayValue:
      serializeArrayValue( value );
      break;
   case Json::objectValue:
      serializeObjectValue( value );
      break;
   default:
      CPPTL_ASSERT_MESSAGE( false, "Unmanaged value type." );
      break;
   }
   return *this;
}

Stream &
Stream::operator >>( Value &value )
{
   Byte control = readNextByte();
   switch ( control )
   {
   case ccBooleanTrue:
      value = Value( true );
      break;
   case ccBooleanFalse:
      value = Value( false );
      break;
   case ccString:
      {
         String str;
         readString( str );
         value = Value( str.c_str() );
      }
      break;
   case ccLookUpDictionnaryEntry:
   case ccNewDictionnaryEntry:
      unserializeObjectValue( control, value );
      break;
   case ccEmptyObjectValue:
      value = Value( Json::objectValue );
      break;
   case ccArrayValue:
      unserializeArrayValue( value );
      break;
   case ccNoneValue:
      value = Value();
      break;
   case ccPositiveReal:
   case ccNegativeReal:
      {
         double real;
         ungetLastByte();
         *this >> real;
         value = Value( real );
      }
      break;
   case ccPositiveInteger:
      {
         LargestUnsignedInt integer;
         ungetLastByte();
         *this >> integer;
         value = Value( Value::UInt(integer) );
      }
      break;
   case ccNegativeInteger:
      {
         LargestInt integer;
         ungetLastByte();
         *this >> integer;
         value = Value( Value::Int(integer) ); 
      }
      break;
   default:
      CPPTL_ASSERT_MESSAGE( false, "Unmanaged value type." );
      break;
   }
   return *this;
}


} // namespace OpenTest
@


1.14
log
@* added unit test for Packets::discardFirstMessage() and fixed bug in Packets.
@
text
@@


1.13
log
@* worked-around security deprecation warning on VC++ 2005.
@
text
@d6 1
d113 2
d201 2
a203 2
   for ( Packet *current = begin.packet_; current != end.packet_; current = current->next_ )
      dist += current->length();
d206 3
a208 1
      dist += begin.packet_->end_ - begin.currentData_;
d212 1
d214 1
@


1.12
log
@- removed infinite recursion in Serializer if there was no int64.
@
text
@d409 3
d413 1
@


1.11
log
@* replaced include/opentest/properties.h with include/json/value.h
* replaced all occurrences of OpenTest::Value and OpenTest::Properties with Json::Value.
@
text
@d346 1
d360 1
a361 2

#ifndef CPPTL_NO_INT64
d363 1
a363 1
Stream::operator <<( CppTL::int64_t value )
d373 1
a373 1
Stream::operator <<( CppTL::uint64_t value )
a377 1
#endif
@


1.10
log
@- replaced usage of OpenTest::Properties with Json::Value.
  Json::Value provides a simpler interface and a standard *simple* serialization
  format.
- jsoncpp has been inlined in CppTL to make deploy easier and remove
  an external dependency.
@
text
@d2 1
a2 1
#include <float.h> // For struct assertion_traits<double>
@


1.9
log
@* fixed compilation without RTTI
* revised stringize implementation to allow an additional customization point by overloading toString().
* added test and corrected bug in serialization/packets implementation.
@
text
@d35 2
a36 2
   ccPropertyList = 0x28,           // '('
   ccNamedPropertiesEnd = 0x29,     // ')'
d39 1
a39 1
   ccEmptyProperties = 0x2c,        // ','
d669 19
a687 2
Stream &
Stream::operator <<( const Properties &properties )
d689 2
a690 2
   Properties::PropertyEnum enumProperties = properties.properties();
   if ( properties.hasList() )
d692 1
a692 3
      doSerializeInteger( ccPropertyList, properties.listSize() );
      for ( unsigned int valueIndex =0; valueIndex < properties.listSize(); ++valueIndex )
         *this << properties.at( valueIndex );
d694 1
a694 1
   else if ( !enumProperties.hasNext() )
d696 3
a698 6
      write( ccEmptyProperties );
   }

   if ( enumProperties.hasNext() )
   {
      do
d700 2
a701 3
         const Property &property = enumProperties.next();
         saveDictionnaryEntry( property.name() );
         *this << property.value();
d703 1
a703 2
      while ( enumProperties.hasNext() );
      write( ccNamedPropertiesEnd );
a704 1
   return *this;
d708 2
a709 2
bool 
Stream::isNamedPropertyControl( Byte control )
d711 5
a715 2
   return control == ccLookUpDictionnaryEntry  
          ||  control == ccNewDictionnaryEntry;
d719 3
a721 2
Stream &
Stream::operator >>( Properties &properties )
d723 1
a723 25
   Byte control = readNextByte();
   if ( control == ccEmptyProperties )
      return *this;
   if ( control == ccPropertyList )
   {
      LargestUnsignedInt length;
      doUnserializeInteger( length );
      while ( length-- )
      {
         Value value;
         *this >> value;
         properties.append( value );
      }
      control = readNextByte();
   }

   if ( !isNamedPropertyControl(control) )
   {
      if ( !properties.hasList() )
         setError( "Expected Properties." );
      else
         ungetLastByte();
      return *this;
   }

d728 1
a728 3
      Value value;
      *this >> value;
      properties.set( name, value );
d732 1
a732 1
   if ( control != ccNamedPropertiesEnd )
a733 1
   return *this;
d742 1
a742 1
   case Value::vtNone:
d745 1
a745 1
   case Value::vtBoolean:
d749 2
a750 2
   case Value::vtSignedInteger:
      *this << value.asInt64();
d752 2
a753 2
   case Value::vtUnsignedInteger:
      *this << value.asUInt64();
d756 1
a756 1
   case Value::vtSignedInteger:
d759 1
a759 1
   case Value::vtUnsignedInteger:
d763 2
a764 2
   case Value::vtReal:
      *this << value.asReal();
d766 2
a767 2
   case Value::vtString:
      *this << value.asString();
d769 5
a773 2
   case Value::vtProperties:
      *this << value.asProperties();
d798 1
a798 1
         value = Value( str );
d803 7
a809 6
   case ccPropertyList:
      {
         ungetLastByte();
         value = Value( Properties() );
         *this >> value.asProperties();
      }
d828 1
a828 1
         value = Value( integer );         
d836 1
a836 1
         value = Value( integer );         
@


1.8
log
@* Started adding unit tests for Packets.
@
text
@d74 1
a74 1
Packets::beginMessage()
d76 1
a76 1
   appendPacketIfFull( externalPos_ );
d78 1
a78 1
   message.position_ = externalPos_;
d85 1
a85 16
Packets::received( void *data, Pos length )
{
   write( externalPos_, static_cast<Byte *>( data ), length );
}


unsigned int 
Packets::send( void *dest, 
               Pos availableLength )
{
   return read( externalPos_, static_cast<Byte *>( dest ), availableLength );
}


void 
Packets::endExternalMessage()
d89 1
a89 10
   messages_.back().length_ = distance( messages_.back().position_, externalPos_ );
}


void 
Packets::endSerializeMessage()
{
   CPPTL_ASSERT_MESSAGE( !messages_.empty()  &&  messages_.back().length_ > 0, 
                         "No message started." );
   messages_.back().length_ = distance( messages_.back().position_, serializePos_ );
d112 18
a129 10
   Packet *current = packetsHead_;
   while ( current != externalPos_.packet_ )
   {
      Packet *toDelete = current;
      current = current->next_;
      CPPTL_ASSERT_MESSAGE( toDelete != serializePos_.packet_, 
                            "Deleting packets used for serialization." );
      delete toDelete;
   }
   packetsHead_ = current;
d133 2
a134 2
unsigned char 
Packets::serializationReadNextByte()
d136 1
a136 1
   if ( serializePos_ )
d138 1
a138 1
      if ( serializePos_.currentData_ == serializePos_.packet_->endInitialized_ )
d140 1
a140 1
         if ( serializePos_.packet_->next_ == 0 )
d142 1
a142 1
         serializePos_.seekToNextPacket();
d144 1
a144 1
      return *(serializePos_.currentData_++);
d150 1
a150 1
Packets::serializationUngetLastByte()
d152 3
a154 3
   CPPTL_ASSERT_MESSAGE( serializePos_, "No byte to unget" );
   if ( serializePos_.currentData_ > serializePos_.packet_->begin_ )
      --serializePos_.currentData_;
d156 1
a156 8
      serializePos_.seekBeforeEndOfPreviousPacket();
}

bool 
Packets::serializationRead( void *buffer, 
                            Pos length )
{
   return read( serializePos_, static_cast<Byte *>( buffer ), length ) == length;
d160 2
a161 2
Packets::serializationWrite( const void *buffer, 
                             Pos length )
d163 1
a163 1
   write( serializePos_, static_cast<const Byte *>( buffer ), length );
d167 1
a167 1
Packets::serializationWrite( Byte byte )
d169 5
a173 2
   if ( serializePos_  &&  serializePos_.currentData_ != serializePos_.packet_->end_ )
      *serializePos_.currentData_++ = byte;
d175 1
a175 1
      write( serializePos_, &byte, 1 );
d180 1
a180 1
Packets::appendPacketIfFull( PacketPos &pos )
d182 1
a182 1
   if ( !pos  ||  pos.currentData_ == pos.packet_->end_ )
d184 1
a184 1
      Packet *packet = new Packet( defaultPacketSize_, pos.packet_ );
d187 3
a189 5
      pos = PacketPos( packet );
      if ( !serializePos_ )
         serializePos_ = pos;
      if ( !externalPos_ )
         externalPos_ = pos;
d219 1
a219 1
      appendPacketIfFull( pos );
d231 1
a231 1
      appendPacketIfFull( pos );
d305 1
a305 1
unsigned char 
d308 1
a308 1
   return packets_.serializationReadNextByte();
d314 1
a314 1
   packets_.serializationUngetLastByte();
d320 1
a320 1
   if ( !packets_.serializationRead( buffer, length ) )
d326 1
a326 1
Stream::write( unsigned char byte )
d328 1
a328 1
   packets_.serializationWrite( byte );
d335 1
a335 1
   packets_.serializationWrite( buffer, length );
d381 1
a381 1
Stream::doSerializeInteger( unsigned char kind, 
d384 2
a385 2
   unsigned char buffer[ (sizeof(value)*8 + ccIntegerBaseShift - 1) / ccIntegerBaseShift ];
   unsigned char *current = buffer + sizeof(buffer);
d388 1
a388 1
      unsigned char reminder = value & ((1 << ccIntegerBaseShift) - 1);
d426 1
a426 1
          CPPTL_ASSERT_MESSAGE( (unsigned char)*current >= ccIntegerZero,
d480 1
a480 1
   unsigned char digit;
d498 1
a498 1
   unsigned char control = readNextByte();
d514 1
a514 1
   value = temp;
d524 1
a524 1
   value = temp;
d535 1
a535 1
   unsigned char control = readNextByte();
d545 1
a545 1
      value = -unsignedValue;
d559 1
a559 1
   unsigned char control = readNextByte();
d574 1
a574 1
   unsigned char control = readNextByte();
d584 1
a584 1
      unsigned char digit = readNextByte();
d614 1
a614 1
   unsigned char control = readNextByte();
d624 1
a624 1
Stream::readDictionnaryEntry ( unsigned char control,
d651 1
a651 1
   unsigned char control = readNextByte();
d700 1
a700 1
Stream::isNamedPropertyControl( unsigned char control )
d710 1
a710 1
   unsigned char control = readNextByte();
d796 1
a796 1
   unsigned char control = readNextByte();
@


1.7
log
@* Added a simple test runner that does not rely on the open test framework to run cppunit2 tests.
* added CppTL::ConstCharView to wrapper const char *strings.
* added CppTL::quoteMultiLineString()
* string assertion output actual and expected using quoteMultiLineString().
* added serialize unit test for basic Properties
* opentest tests now use the LightTestRunner.
@
text
@d55 1
a55 1
Packets::Packets()
d57 1
a57 1
   , defaultPacketSize_( 16384 )
@


1.6
log
@Made Value operator == deal nicely with int/unsigned int value comparison.
@
text
@d39 1
d111 1
a111 1
   CPPTL_ASSERT_MESSAGE( !messages_.empty()  &&  messages_.back().length_ == 0, 
d488 1
d694 1
d701 4
a705 1
   Properties::PropertyEnum enumProperties = properties.properties();
d733 2
@


1.5
log
@* added more unit tests for serializer
* fixed bugs
* added strict operator == for Value and Properties.
@
text
@d370 1
a370 1
   return *this << CppTL::int64_t( value );
@


1.4
log
@* started adding unit tests for opentest
* added serializer unit test squeleton
* fixed some bug in serializer
* added opentesttest project to VS solution.
@
text
@d43 3
a45 1
   ccIntegerBaseShift = 6           // power of 2 for encoding base (0x40 = 1 << 6)
d432 3
d436 1
a436 1
   for ( char *current = &buffer[0]; current != end; ++current )
d439 1
a439 1
         *current = ccPositiveReal;
d441 1
a441 1
         *current = ccNegativeReal;
d451 1
a451 1
   if ( buffer[0] == ccNegativeReal )
d459 4
a462 1
      write( buffer, length );
d472 1
d605 1
a605 1
      if ( digit == ccPositiveReal )
d607 1
a607 1
      else if ( digit == ccNegativeReal )
d671 4
a674 1
   if ( length <= sizeof(stringBuffer_) )
@


1.3
log
@* RemoteMessage data are interleaved with Packets.
@
text
@d97 1
a97 1
Packets::endMessage()
d105 9
d187 1
a187 1
Packets::serializationWrite( unsigned char byte )
d189 4
d403 1
a403 1
   unsigned char buffer[ (sizeof(value) + ccIntegerBaseShift - 1) / ccIntegerBaseShift ];
d492 1
a492 1
   while ( (digit = readNextByte()) < ccIntegerZero )
d519 1
a519 1
#ifdef CPPTL_NO_INT64
@


1.2
log
@Extracted packet management to handle the dual packet cursor cleanly (cursor for serialization and transport).
@
text
@d4 4
a7 1
 
d105 32
@


1.1
log
@- serialization layer on top of growing buffer for one way communication.
@
text
@d6 1
d43 5
d49 3
a51 7

Stream::Stream() 
   : current_( buffers_.begin() )
   , currentData_( 0 )
   , endData_( 0 )
   , writeBufferSize_( 16384 )
   , error_( 0 )
d55 1
a55 1
Stream::~Stream() 
d57 2
a58 1
   while ( !buffers_.empty() )
d60 3
a62 2
      delete[] (unsigned char *)buffers_.back().data_;
      buffers_.pop_back();
d67 13
a79 2
bool 
Stream::inError() const
d81 1
a81 1
   return error_ != 0;
d84 4
a87 2
Stream &
Stream::setError( const char *errorMessage )
d89 1
a89 3
   if ( !error_ )
      error_ = errorMessage;
   return *this;
d94 1
a94 2
Stream::addBuffer( unsigned int length, 
                   const void *data )
d96 3
a98 5
   write( data, length );

   current_ = buffers_.begin();
   currentData_ = current_->data_;
   endData_ = currentData_ + length;
d103 1
a103 1
Stream::readNextByte()
d105 1
a105 4
   if ( currentData_ != endData_ )
      return *currentData_++;

   if ( current_ != buffers_.end() )
d107 1
a107 2
      ++current_;
      if ( current_ != buffers_.end() )
d109 3
a111 5
         currentData_ = current_->data_;
         endData_ = currentData_ + current_->length_;
         CPPTL_ASSERT_MESSAGE( currentData_ != endData_, 
                               "invariant violation: 0 length data buffer" );
         return *currentData_++;
d113 1
d119 95
a213 1
Stream::ungetLastByte()
d215 5
a219 1
   if ( current_ != buffers_.end() )
d221 8
a228 10
      if ( current_->data_ != currentData_ )
      {
         --currentData_;
         return;
      }
      CPPTL_ASSERT_MESSAGE( current_ != buffers_.begin(), 
                            "No byte to 'unput'" );
      --current_;
      endData_ = current_->data_ + current_->length_;
      currentData_ =  endData_ - 1;
d230 56
d291 2
a292 29
   unsigned char *target = static_cast<unsigned char *>( buffer );
   unsigned int lengthToCopy = CPPTL_MIN( length, endData_ - currentData_ );
   memcpy( target, currentData_, lengthToCopy );
   length -= lengthToCopy;
   currentData_ += lengthToCopy;
   if ( length != 0 ) // there was not enough data, use next buffers
   {
      target += lengthToCopy;
      ++current_;
      while ( current_ != buffers_.end() )
      {
         lengthToCopy = CPPTL_MIN( length, current_->length_ );
         memcpy( target, current_->data_, lengthToCopy );
         target += lengthToCopy;
         length -= lengthToCopy;
         if ( length == 0 )
         {
            currentData_ = current_->data_ + lengthToCopy;
            endData_ = current_->data_ + current_->length_;
            break;
         }
         ++current_;
      }
      if ( length != 0 )
      {
         setError( "Attempted to read beyond buffer end." );
         currentData_ = endData_;
      }
   }
d299 1
a299 4
   if ( currentData_ != endData_ )
      *currentData_++ = byte;
   else
      write( &byte, 1 );
d306 1
a306 24
   if ( length == 0 )
      return;

   const unsigned char *source = static_cast<const unsigned char *>( buffer );
   unsigned int availableLength = endData_ - currentData_;
   if ( availableLength < length )
   {
      memcpy( currentData_, source, availableLength );
      source += availableLength;
      length -= availableLength;
   }

   unsigned int newBufferLength = length + writeBufferSize_;
   BufferData dataBuffer;
   dataBuffer.length_ = newBufferLength;
   typedef unsigned char BufferElementType;
   unsigned char *newData = new BufferElementType[ newBufferLength ];
   memcpy( newData, source, length );
   dataBuffer.data_ = newData;
   buffers_.push_back( dataBuffer );

   current_ = buffers_.end() - 1;
   currentData_ = newData + length;
   endData_ = newData + newBufferLength;
@

