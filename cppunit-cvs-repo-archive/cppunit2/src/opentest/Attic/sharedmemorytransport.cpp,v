head	1.13;
access;
symbols;
locks; strict;
comment	@// @;


1.13
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.12;

1.12
date	2006.06.05.12.05.57;	author blep;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.11.11.46.25;	author blep;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.10.22.05.46;	author blep;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.10.08.30.33;	author blep;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.08.22.01.20;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.07.23.02.56;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.01.18.26.17;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.31.08.08.38;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.06.07.31.42;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.01.08.19.36;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.30.21.48.09;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.26.21.24.30;	author blep;	state Exp;
branches;
next	;


desc
@@


1.13
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#include <opentest/sharedmemorytransport.h>
#ifndef OPENTEST_NO_SHAREDMEMORYTRANSPORT
# include <opentest/remoteinterfaces.h>
# include <opentest/serializer.h>
# include <cpptl/thread.h>
# include <tchar.h>

# define WIN32_LEAN_AND_MEAN 
# define NOGDI
# define NOUSER
# define NOKERNEL
# define NOSOUND
# include <windows.h>

/* Importance notes:
 * Be sure to use windows "macro" to access system access call. This ensure we can compile
 * the code as either unicode or ansi. Some Windows family OS only have 'unicode' system call.
 */



namespace OpenTest {


// Log macro (will probably be replace with a mini logging framework as such thing are required
// to debug distributed app).
#define OPENTEST_SHMEM_LOG \
   if ( config_.log_ ) config_.log_


static const DWORD magicKey = 0x43555431;

static volatile unsigned int serial = 1;
static CppTL::Mutex serialLock;

static LPSECURITY_ATTRIBUTES setChildProcessCanInheritSecurity( SECURITY_ATTRIBUTES &saAttr )
{
   saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
   saAttr.bInheritHandle = TRUE; // inherit handle
   saAttr.lpSecurityDescriptor = NULL;
   return &saAttr;
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class AutoHandle
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

class AutoHandle
{
public:
   AutoHandle()
      : handle_( 0 )
   {
   }

   explicit AutoHandle( HANDLE handle )
      : handle_( handle )
   {
   }

   ~AutoHandle()
   {
      if ( handle_ )
         ::CloseHandle( handle_ );
   }

   operator HANDLE () const
   {
      return handle_;
   }

   AutoHandle &reset( HANDLE handle )
   {
      if ( handle != handle_ )
      {
         if ( handle_ )
            ::CloseHandle( handle_ );
         handle_ = handle;
      }
      return *this;
   }

private:
   AutoHandle( const AutoHandle &other );
   AutoHandle &operator =( const AutoHandle &other );

   HANDLE handle_;
};

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class ScopedMutexLock
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
class ScopedMutexLock
{
public:
   ScopedMutexLock( HANDLE mutex )
      : mutex_( mutex )
   {
      ::WaitForSingleObject( mutex, INFINITE );
   }

   ~ScopedMutexLock()
   {
      ::ReleaseMutex( mutex_ );
   }

private:
   HANDLE mutex_;
};


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class BaseEvent
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

class BaseEvent
{
public:
   void signal()
   {
      ::SetEvent( hEvent_ );
   }

   void reset()
   {
      ::ResetEvent( hEvent_ );
   }

   bool isSignaled() const
   {
      return ::WaitForSingleObject( hEvent_, 0 ) == WAIT_OBJECT_0;
   }

   HANDLE get() const
   {
      return hEvent_;
   }

protected:
   AutoHandle hEvent_;
};


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class NamedEvent
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

class NamedEvent : public BaseEvent
{
public:
   HANDLE create( const TCHAR *name, bool manualReset = false )
   {
      SECURITY_ATTRIBUTES sa;
      hEvent_.reset( ::CreateEvent( setChildProcessCanInheritSecurity(sa),
                                    manualReset ? TRUE : FALSE,
                                    FALSE,
                                    name ) );
      return get();
   }
};


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class AnonymousManualEvent
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

class AnonymousManualEvent : public BaseEvent
{
public:
   AnonymousManualEvent()
   {
      SECURITY_ATTRIBUTES sa;
      hEvent_.reset( ::CreateEvent( setChildProcessCanInheritSecurity(sa),
                               TRUE,
                               FALSE,
                               0 ) );
   }
};


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class SharedMemoryTransportImpl
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////


class SharedMemoryTransportImpl
{
public:
   typedef unsigned char Byte;
   typedef DWORD Pos;

   SharedMemoryTransportImpl( const SharedMemoryConfig &config );
   SharedMemoryTransportImpl( const String &transportName,
                              const SharedMemoryConfig &config );
   virtual ~SharedMemoryTransportImpl();

   std::string transportName() const;

   // Called from 'main' thread
   void send( const RemoteMessagePtr &message );

   // Called from 'main' thread
   void dispatchReceivedMessages( RemoteMessageServer &server );

#pragma pack(push, 1)
   // The structure CircularBuffer & SharedData are 
   // directly mapped to shared memory.
   // They should contains no C++ object (memory organization can depend on compilation options).
   // Name are declared from the server side point of view.
   // Pragma directive must be used to ensure they have the same binary
   // representation regarless of compilation option.
   struct CircularBuffer
   {
      Pos availableForReadingSequentially() const
      {
         return writePos_ <= size_ ? writePos_ - readPos_
                                   : size_ - readPos_;
      }

      Pos availableForWritingSequentially() const
      {
         return writePos_ <= size_ ? size_ - writePos_ 
                                   : readPos_ - (writePos_ - size_);
      }

      Pos normalizeWritePos() const
      {
         return writePos_ >= size_ ? writePos_ - size_ : writePos_;
      }

      void read( Pos length )
      {
         readPos_ += length;
         if ( readPos_ == size_ )
         {
            CPPTL_ASSERT_MESSAGE( writePos_ >= size_, "Invalid write position" );
            writePos_ -= size_;
         }
      }

      void wrote( Pos length )
      {
         writePos_ += length;
      }

      Pos size_;
      Pos readPos_;  // between 0 and size_
      Pos writePos_; // between 0 and 2*size_. if > size_ then reading from read-> size + 0 -> write%size_
   };


   struct SharedData
   {
      DWORD structSize_; /// size of the SharedData struct (to detect incompatible struct due to compilation settings)
      DWORD magic_;
      HANDLE mutex_;
      CircularBuffer circularBuffers_[2];
   };
#pragma pack(pop)

private:
   enum BufferState
   {
      bsSize = 0,
      bsMessage
   };

   struct BufferInfo
   {
      void read( const char *hint, Pos readLength )
      {
      // OPENTEST_SHMEM_LOG( "read: %s, read %d bytes at offset %d", hint, readLength, circular_->readPos_ );
         circular_->read( readLength );
         processedLength_ += readLength;
      }

      void write( const char *hint, Pos writeLength )
      {
      // OPENTEST_SHMEM_LOG( "write: %s, wrote %d bytes at offset %d", hint, writeLength, circular_->normalizedWritePos() );
         circular_->wrote( writeLength );
         processedLength_ += writeLength;
      }

      NamedEvent event_;
      Stream stream_;
      BufferState state_;
      CircularBuffer *circular_;
      Byte *data_;
      DWORD messageLength_;
      Pos processedLength_;
   };

   void createSharedMemoryRegion();
   void openSharedMemoryRegion();
   void setSharedMemoryRegion();
   void initializeCircularBuffer( CircularBuffer &buffer );
   HANDLE autoManage( HANDLE handle );
   void setUpReadWriteBuffers();
   void checkManualEvents();
   static DWORD WINAPI threadBootstrap( void *p );
   void startThread();
   void stopThread();
   void threadMain();
   void prepareWaitObjects();
   const char *getWaitObjectName( DWORD index );
   void prepareMessageToSend();
   void readAndSendPendingData();
   void pushReceivedMessages();
   void readPendingData();
   void writePendingData();
   BufferInfo &getReadBuffer();
   BufferInfo &getWriteBuffer();

private:
   typedef std::deque<RemoteMessagePtr> RemoteMessages;
   RemoteMessages messagesToSend_;
   RemoteMessages messagesToDispatch_;
   CppTL::Mutex messagesToSendLock_;
   CppTL::Mutex messagesToDispatchLock_;
   std::vector<HANDLE> handles_;
   std::vector<HANDLE> waitObjects_;
   SharedMemoryConfig config_;
   BufferInfo buffers_[2];
   AnonymousManualEvent stopEvent_;
   AnonymousManualEvent sendMessageEvent_;
   AutoHandle hSharedMemory_;
   AutoHandle thread_;
   SharedData *shared_;
   CppTL::ConstString transportName_;
   unsigned int id_;
   TCHAR nameBuffer_[32];
   unsigned int nameLength_;
   bool isConnectionCreator_;
};

SharedMemoryTransportImpl::SharedMemoryTransportImpl( const SharedMemoryConfig &config )
   : config_( config )
   , isConnectionCreator_( true )
{
   {
      CppTL::Mutex::ScopedLockGuard guard( serialLock );
      id_ = serial++;
   }
   unsigned int pid = ::GetCurrentProcessId();
   nameLength_ = _stprintf( nameBuffer_, _T("cpput_%08x_%08x"), pid, id_ );
   CPPTL_ASSERT_MESSAGE( nameLength_ < sizeof(nameBuffer_)-1, 
                         "buffer overflow" );
   transportName_ = nameBuffer_;

   createSharedMemoryRegion();
   setUpReadWriteBuffers();
   checkManualEvents();
   startThread();
}


SharedMemoryTransportImpl::SharedMemoryTransportImpl( const String &transportName,
                                                      const SharedMemoryConfig &config )
   : config_( config )
   , isConnectionCreator_( false )
{
   if ( transportName.length() > sizeof(nameBuffer_)/sizeof(TCHAR)-4 )
      throw SharedMemoryError( "Shared memory transport name too long." );
#ifdef _UNICODE  // Use VC++ CRT extension to handle ansi->unicode conversion.
# ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
   nameLength_ = wprintf_s( nameBuffer_, sizeof(buffer), L"%S", transportName.c_str() );
# else	
   nameLength_ = wprintf( nameBuffer_, L"%S", transportName.c_str() );
# endif
#else
# ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
   nameLength_ = sprintf_s( nameBuffer_, sizeof(nameBuffer_), "%s", transportName.c_str() );
# else	
   nameLength_ = sprintf( nameBuffer_, "%s", transportName.c_str() );
# endif
#endif
   openSharedMemoryRegion();
   setUpReadWriteBuffers();
   checkManualEvents();
   startThread();
}

SharedMemoryTransportImpl::~SharedMemoryTransportImpl()
{
   stopThread();
   while ( !handles_.empty() )
   {
      ::CloseHandle( handles_.back() );
      handles_.pop_back();
   }
   handles_.clear();
}


void 
SharedMemoryTransportImpl::createSharedMemoryRegion()
{
   SECURITY_ATTRIBUTES saAttr;
   setChildProcessCanInheritSecurity( saAttr );

   DWORD fileMappingSize = sizeof(SharedData) + 2*config_.bufferSize_;
   hSharedMemory_.reset( ::CreateFileMapping( INVALID_HANDLE_VALUE,
            &saAttr,          // inherits handle
            PAGE_READWRITE,
            0,                // max size (hi-order)
            fileMappingSize,  // max size (low-order)
            nameBuffer_ ) );     // name
   if ( hSharedMemory_ == 0 )
      throw SharedMemoryError( "Failed to create shared memory region." );

   setSharedMemoryRegion();
   // Initialize shared memory region
   memset( shared_, 0xba, fileMappingSize ); // fill shared memory region with garbage for easier debugging
   shared_->structSize_ = sizeof(SharedData);
   shared_->mutex_ = autoManage( ::CreateMutex( &saAttr, FALSE, 0 ) );
   shared_->magic_ = magicKey;
   initializeCircularBuffer( shared_->circularBuffers_[0] );
   initializeCircularBuffer( shared_->circularBuffers_[1] );

   if ( !shared_->mutex_ )
      throw SharedMemoryError( "Failed to initialize shared memory structure (mutex creation failed)." );
}


std::string 
SharedMemoryTransportImpl::transportName() const
{
   return transportName_.c_str();
}


void
SharedMemoryTransportImpl::openSharedMemoryRegion()
{
   if ( config_.singleProcessMasterTransport_ )
   {
      shared_ = config_.singleProcessMasterTransport_->impl_->shared_;
   }
   else
   {
      hSharedMemory_.reset( ::OpenFileMapping( FILE_MAP_ALL_ACCESS,
               TRUE,
               nameBuffer_ ) );
      if ( hSharedMemory_ == 0 )
         throw SharedMemoryError( "Failed to open specified shared memory region." );

      setSharedMemoryRegion();
   }
}


void
SharedMemoryTransportImpl::setSharedMemoryRegion()
{
   LPVOID lpMapAddress = ::MapViewOfFile(
      hSharedMemory_,                    // handle to mapping object 
      FILE_MAP_ALL_ACCESS,               // read/write permission 
      0,                                 // max. object size 
      0,                                 // size of hFile 
      0 );                               // map entire file 

   shared_ = static_cast<SharedData *>( lpMapAddress );
}


void 
SharedMemoryTransportImpl::initializeCircularBuffer( CircularBuffer &buffer )
{
   buffer.size_ = config_.bufferSize_;
   buffer.readPos_ = 0;
   buffer.writePos_ = 0;
}


HANDLE 
SharedMemoryTransportImpl::autoManage( HANDLE handle )
{
   handles_.push_back( handle );
   return handle;
}


void 
SharedMemoryTransportImpl::setUpReadWriteBuffers()
{
   for ( int index = 0; index < 2; ++index )
   {
      static const TCHAR suffixes[] = _T( "rw" ); // read/write event name suffix.

      int orientedIndex = isConnectionCreator_ ? index : 1 - index;
      BufferInfo &buffer = buffers_[ orientedIndex ];

      nameBuffer_[nameLength_] = suffixes[index];
      nameBuffer_[nameLength_+1] = 0;
      if ( buffer.event_.create( nameBuffer_, true ) == 0 )
         throw SharedMemoryError( "Failed to create named event." );
      buffer.state_ = bsSize;
      buffer.circular_ = &shared_->circularBuffers_[ index ];
      buffer.data_ = reinterpret_cast<Byte *>( shared_ ) + sizeof(SharedData);
      if ( index > 0 )
         buffer.data_ += shared_->circularBuffers_[ 0 ].size_;
      buffer.processedLength_ = 0;
      buffer.messageLength_ = 0;
   }
   nameBuffer_[nameLength_] = 0;
}


void 
SharedMemoryTransportImpl::checkManualEvents()
{
   if ( stopEvent_.get() == 0  ||  sendMessageEvent_.get() == 0 )
      throw SharedMemoryError( "Failed to creae manual events." );
}


// Call to this method may come from another thread.
void 
SharedMemoryTransportImpl::send( const RemoteMessagePtr &message )
{
   OPENTEST_SHMEM_LOG( "send(), acquiring messagesToSendLock_" );
   CppTL::Mutex::ScopedLockGuard guard( messagesToSendLock_ );
   messagesToSend_.push_back( message );
   sendMessageEvent_.signal();
   OPENTEST_SHMEM_LOG( "send(), message pushed in messagesToSend_; sendMessageEvent_ signaled." );
}


void 
SharedMemoryTransportImpl::dispatchReceivedMessages( RemoteMessageServer &server )
{
   RemoteMessages messages;
   {
      CppTL::Mutex::ScopedLockGuard guard( messagesToDispatchLock_ );
      messages.swap( messagesToDispatch_ );
   }

   while ( !messages.empty() )
   {
      server.dispatchMessage( messages.front() );
      messages.pop_front();
   }
}


DWORD WINAPI 
SharedMemoryTransportImpl::threadBootstrap( void *p )
{
   static_cast<SharedMemoryTransportImpl *>( p )->threadMain();
   return 0;
}


void 
SharedMemoryTransportImpl::startThread()
{
   if ( !thread_ )
   {
      DWORD threadId;
      thread_.reset( ::CreateThread( 0, 0, 
                                &SharedMemoryTransportImpl::threadBootstrap, 
                                this, 0, &threadId ) );
      if ( thread_ == 0 )
         throw SharedMemoryError( "Failed to create thread." );
   }
}

void 
SharedMemoryTransportImpl::stopThread()
{
   if ( thread_ )
   {
      OPENTEST_SHMEM_LOG( "Stopping thread..." );
      stopEvent_.signal();
      WaitForSingleObject( thread_, INFINITE ); // join thread
      stopEvent_.reset();
      OPENTEST_SHMEM_LOG( "Thread stopped." );
   }
}


void 
SharedMemoryTransportImpl::threadMain()
{
   try
   {
      OPENTEST_SHMEM_LOG( "Thread started." );

      prepareWaitObjects();
      while ( true )
      {
         OPENTEST_SHMEM_LOG( "Waiting event");
         DWORD event = WaitForMultipleObjects( waitObjects_.size(), 
                                               &waitObjects_[0], 
                                               FALSE, 
                                               INFINITE );
         event -= WAIT_OBJECT_0;
         if ( event <0  ||  event > waitObjects_.size() )
         {
            if ( event + WAIT_OBJECT_0 == WAIT_TIMEOUT )
               OPENTEST_SHMEM_LOG( "timeout event !" );
            else if ( event + WAIT_OBJECT_0 == WAIT_FAILED )
            {
               OPENTEST_SHMEM_LOG( "event wait failed" );
            }
            else
               OPENTEST_SHMEM_LOG("abandonned event: %d!", event );
            break; // timeout or abandonned event => child process died.
         }

         OPENTEST_SHMEM_LOG( "Event signaled: %s (event#%d)", getWaitObjectName(event), event );
         
         if ( waitObjects_[event] == stopEvent_.get() )
         {
            OPENTEST_SHMEM_LOG( "Stop event signaled !" );
            break;
         }

         prepareMessageToSend();
         readAndSendPendingData();
         pushReceivedMessages();
      }
      OPENTEST_SHMEM_LOG( "Thread stopped." );
   }
   catch ( const std::exception &e )
   {
      OPENTEST_SHMEM_LOG( "thread aborted: %s", e.what() );
   }
   catch ( ... )
   {
      OPENTEST_SHMEM_LOG( "thread aborted with an unspecified exception." );
      throw;
   }
}


void 
SharedMemoryTransportImpl::prepareWaitObjects()
{
   waitObjects_.clear();
   waitObjects_.push_back( stopEvent_.get() );
   waitObjects_.push_back( sendMessageEvent_.get() );
   waitObjects_.push_back( buffers_[0].event_.get() );
   waitObjects_.push_back( buffers_[1].event_.get() );
}


const char *
SharedMemoryTransportImpl::getWaitObjectName( DWORD index )
{
   CPPTL_ASSERT_MESSAGE( index < 4, "Bad event index" );
   static const char *names[] = { "stopEvent_", "sendMessageEvent_", 
                                "buffers_[0].event_", "buffers_[1].event_" };
   return names[index];
}


void
SharedMemoryTransportImpl::prepareMessageToSend()
{
   if ( !sendMessageEvent_.isSignaled() )
      return;

   RemoteMessages messages;
   {
      OPENTEST_SHMEM_LOG( "Messaging thread acquiring messagesToSendLock_" );
      CppTL::Mutex::ScopedLockGuard guard( messagesToSendLock_ );
      messagesToSend_.swap( messages );
      sendMessageEvent_.reset();
   }
   OPENTEST_SHMEM_LOG( "Messaging thread released messagesToSendLock_" );

   BufferInfo &buffer = getWriteBuffer();
   while ( !messages.empty() )
   {
      buffer.stream_.packets().beginWriteMessage();
      buffer.stream_ << messages.front();
      buffer.stream_.packets().endWriteMessage();
      messages.pop_front();
   }
}


void
SharedMemoryTransportImpl::readAndSendPendingData()
{
   if ( buffers_[0].event_.isSignaled()  
        ||  buffers_[1].event_.isSignaled()
        ||  getWriteBuffer().stream_.packets().hasPendingMessage() )
   {
      OPENTEST_SHMEM_LOG( "Trying to acquire mutex: shared_->mutex_ [%p]", shared_->mutex_ );
      ScopedMutexLock guard( shared_->mutex_ );
      OPENTEST_SHMEM_LOG( "Acquired mutex: shared_->mutex_ [%p]", shared_->mutex_ );
      readPendingData();
      writePendingData();
      OPENTEST_SHMEM_LOG( "Releasing mutex: shared_->mutex_ [%p]", shared_->mutex_ );
   }
}


void 
SharedMemoryTransportImpl::readPendingData()
{
   BufferInfo &buffer = getReadBuffer();
   buffer.event_.reset();
   OPENTEST_SHMEM_LOG( "Resetting buffers_[0].buffer.event_" );
   Pos oldReadPos = buffer.circular_->readPos_;
   while ( true )
   {
      Pos available = buffer.circular_->availableForReadingSequentially();
      if ( available == 0 )
         break;
      switch ( buffer.state_ )
      {
      case bsSize:
         {
            Pos toRead = CPPTL_MIN( available, 
                                    sizeof(buffer.messageLength_) - buffer.processedLength_ );
            Byte *target = buffer.data_ + buffer.processedLength_+ buffer.circular_->readPos_;
            memcpy( reinterpret_cast<Byte *>(&buffer.messageLength_) + buffer.processedLength_,
                  target,
                  toRead );
            buffer.read( "Message size", toRead );
            if ( buffer.processedLength_ == sizeof(buffer.messageLength_) )
            {
               buffer.state_ = bsMessage;
               buffer.processedLength_ = 0;
               OPENTEST_SHMEM_LOG( "read: message size is %d", buffer.messageLength_ );
               buffer.stream_.packets().beginWriteMessage();
            }
         }
         break;
      case bsMessage:
         {
            Pos toRead = CPPTL_MIN( available, buffer.messageLength_ );
            Byte *target = buffer.data_ + buffer.processedLength_+ buffer.circular_->readPos_;
            buffer.stream_.packets().write( target, 
                                            toRead );
            buffer.read( "Message content", toRead );
            if ( buffer.processedLength_ == buffer.messageLength_ )
            {
               OPENTEST_SHMEM_LOG( "read: message completly received" );
               buffer.stream_.packets().endWriteMessage();
               buffer.state_ = bsSize;
               buffer.processedLength_ = 0;
            }
         }
         break;
      default:
         CPPTL_ASSERT_MESSAGE( false, "Invalid buffer state." );
         break;
      }
   }

   if ( oldReadPos != buffer.circular_->readPos_ )
   {
      OPENTEST_SHMEM_LOG( "Signaling buffers_[0].buffer.event_" );
      buffer.event_.signal();
   }
}

void 
SharedMemoryTransportImpl::writePendingData()
{
   BufferInfo &buffer = getWriteBuffer();
   OPENTEST_SHMEM_LOG( "Resetting buffers_[1].buffer.event_" );
   buffer.event_.reset();
   Pos oldWritePos = buffer.circular_->writePos_;
   while ( buffer.stream_.packets().hasPendingMessage() )
   {
      Pos available = buffer.circular_->availableForWritingSequentially();
      if ( available == 0 )
         break;
      switch ( buffer.state_ )
      {
      case bsSize:
         {
            buffer.messageLength_ = buffer.stream_.packets().getFirstMessageLength();

            Pos toWrite = CPPTL_MIN( available, 
                                     sizeof(buffer.messageLength_) - buffer.processedLength_ );
            Byte *target = buffer.data_ + buffer.circular_->normalizeWritePos() + buffer.processedLength_;
            memcpy( target,
                    reinterpret_cast<Byte *>(&buffer.messageLength_) + buffer.processedLength_,
                    toWrite );
            buffer.write( "Message size", toWrite );
            if ( buffer.processedLength_ == sizeof(buffer.messageLength_) )
            {
               buffer.state_ = bsMessage;
               buffer.processedLength_ = 0;
               OPENTEST_SHMEM_LOG( "write: message size is %d", buffer.messageLength_ );
            }
         }
         break;
      case bsMessage:
         {
            Pos toWrite = CPPTL_MIN( available, buffer.messageLength_ );
            Byte *target = buffer.data_ + buffer.circular_->normalizeWritePos() + buffer.processedLength_;
            Pos written = buffer.stream_.packets().read( target, toWrite );
            buffer.write( "Message content", written );
            if ( buffer.processedLength_ == buffer.messageLength_ )
            {
               OPENTEST_SHMEM_LOG( "write: message completly sent" );
               buffer.state_ = bsSize;
               buffer.processedLength_ = 0;
               buffer.stream_.packets().discardFirstMessage();
            }
         }
         break;
      default:
         CPPTL_ASSERT_MESSAGE( false, "Invalid buffer state." );
         break;
      }
   }
   if ( oldWritePos != buffer.circular_->writePos_ )
   {
      OPENTEST_SHMEM_LOG( "signaling buffers_[1].buffer.event_" );
      buffer.event_.signal();
   }
}


void 
SharedMemoryTransportImpl::pushReceivedMessages()
{
   RemoteMessages messages;
   BufferInfo &buffer = getReadBuffer();
   while ( buffer.stream_.packets().hasPendingMessage() )
   {
      RemoteMessagePtr message;
      buffer.stream_ >> message;
      if ( message )
         messages.push_back( message );
      buffer.stream_.packets().discardFirstMessage();
   }

   CppTL::Mutex::ScopedLockGuard guard( messagesToDispatchLock_ );
   OPENTEST_SHMEM_LOG( "Pushing %d unserialized messages messagesToDispatch_ queue.", int(messages.size()) );
   messagesToDispatch_.insert( messagesToDispatch_.end(),
                               messages.begin(),
                               messages.end() );
}


SharedMemoryTransportImpl::BufferInfo &
SharedMemoryTransportImpl::getReadBuffer()
{
   return buffers_[0];
}


SharedMemoryTransportImpl::BufferInfo &
SharedMemoryTransportImpl::getWriteBuffer()
{
   return buffers_[1];
}



// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class SharedMemoryTransport
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////


SharedMemoryTransport::SharedMemoryTransport( const SharedMemoryConfig &config )
   : impl_( new SharedMemoryTransportImpl( config ) )
{
}

SharedMemoryTransport::SharedMemoryTransport( const String &transportName,
                                              const SharedMemoryConfig &config )
   : impl_( new SharedMemoryTransportImpl( transportName, config ) ) 
{
}

SharedMemoryTransport::~SharedMemoryTransport()
{
   delete impl_;
}


std::string 
SharedMemoryTransport::transportName() const
{
   return impl_->transportName();
}

void 
SharedMemoryTransport::sendMessage( const RemoteMessagePtr &message )
{
   impl_->send( message );
}


void 
SharedMemoryTransport::dispatchReceivedMessages( RemoteMessageServer &server )
{
   impl_->dispatchReceivedMessages( server );
}


} // namespace OpenTest

#endif // OPENTEST_NO_SHAREDMEMORYTRANSPORT
@


1.12
log
@* a bit of clean-up
@
text
@@


1.11
log
@* fixed more sharedmemorytransport bugs (named event switched to manual reset, incorrect read/write buffer in slave thread, bad buffer indexing in read/write loop)
@
text
@d851 1
@


1.10
log
@* better event logging
* fixed bug (incorrect message length when sending second message)
* fixed bug: event not reseted  after flushing messageToSent queue.
@
text
@d160 1
a160 1
   HANDLE create( const TCHAR *name )
d164 3
a166 3
                               FALSE,
                               FALSE,
                               name ) );
a424 1

d426 1
d508 1
a508 1
      if ( buffer.event_.create( nameBuffer_ ) == 0 )
d511 1
a511 1
      buffer.circular_ = &shared_->circularBuffers_[ orientedIndex ];
d513 1
a513 1
      if ( orientedIndex > 0 )
d704 1
a704 1
      OPENTEST_SHMEM_LOG( "Acquiring shared_->mutex_" );
d706 1
a706 1
      OPENTEST_SHMEM_LOG( "Acquired shared_->mutex_" );
d709 1
a710 1
   OPENTEST_SHMEM_LOG( "Released shared_->mutex_" );
d719 1
d732 1
d734 1
a734 1
                  buffer.data_ + buffer.processedLength_,
d749 2
a750 1
            buffer.stream_.packets().write( buffer.data_ + buffer.circular_->readPos_, 
d769 2
d772 1
d779 1
d795 2
a796 1
            memcpy( buffer.data_ + buffer.processedLength_,
d811 1
a811 1
            Byte *target = buffer.data_ + buffer.circular_->normalizeWritePos();
d829 2
d832 1
@


1.9
log
@* fixed bad 'Byte' typedef causing bad memory access.
@
text
@d318 1
a610 1
         OPENTEST_SHMEM_LOG( "Event signaled: %d", event );
d623 3
d661 10
d682 1
d706 1
d784 1
a784 2
            if ( buffer.messageLength_ == 0 )
               buffer.messageLength_ = buffer.stream_.packets().getFirstMessageLength();
@


1.8
log
@* took out the DuplicateHandle used for reference couting (a different handle was returned, and the previous handle became invalid). Explicit life cycle management is used instead.
@
text
@d202 1
a203 1
   typedef unsigned char *Byte;
d360 1
a360 1
   transportName_ = nameLength_;
d447 11
a457 5
   hSharedMemory_.reset( ::OpenFileMapping( FILE_MAP_ALL_ACCESS,
            TRUE,
            nameBuffer_ ) );
   if ( hSharedMemory_ == 0 )
      throw SharedMemoryError( "Failed to open specified shared memory region." );
d459 2
a460 1
   setSharedMemoryRegion();
d515 1
@


1.7
log
@* added end to end test for shared memory transport.
@
text
@a63 15
   AutoHandle( const AutoHandle &other )
      : handle_( 0 )
   {
      if ( other.handle_ )
      {
         ::DuplicateHandle( GetCurrentProcess(), 
                            other.handle_,
                            GetCurrentProcess(), 
                            &handle_, 
                            0, 
                            TRUE,   // handle may be inherited by child process
                            DUPLICATE_SAME_ACCESS );
      }
   }

d75 1
a75 1
   AutoHandle &operator =( HANDLE handle )
d86 3
a88 4
   AutoHandle &operator =( const AutoHandle &other )
   {
      return *this = other.handle_;
   }
a89 1
private:
d163 1
a163 1
      hEvent_ = ::CreateEvent( setChildProcessCanInheritSecurity(sa),
d166 1
a166 1
                               name );
d184 1
a184 1
      hEvent_ = ::CreateEvent( setChildProcessCanInheritSecurity(sa),
d187 1
a187 1
                               0 );
d332 1
a332 1
   std::vector<AutoHandle> handles_;
d341 1
d360 1
d398 6
d414 1
a414 1
   hSharedMemory_ = ::CreateFileMapping( INVALID_HANDLE_VALUE,
d419 1
a419 1
            nameBuffer_ );     // name
d440 1
a440 1
   return nameBuffer_;     // @@todo change this to work if TCHAR = wchar_t
d447 1
a447 1
   hSharedMemory_ = ::OpenFileMapping( FILE_MAP_ALL_ACCESS,
d449 1
a449 1
            nameBuffer_ );
d483 1
a483 2
   AutoHandle autoHandle( handle );
   handles_.push_back( autoHandle );
d564 1
a564 1
      thread_ = ::CreateThread( 0, 0, 
d566 1
a566 1
                                this, 0, &threadId );
d634 1
d658 1
d662 1
d682 1
d687 1
@


1.6
log
@* worked-around security deprecation warning on VC++ 2005.
@
text
@d25 6
d227 2
d302 1
a302 1
      // log( "read: %s, read %d bytes at offset %d", hint, readLength, circular_->readPos_ );
d309 1
a309 1
      // log( "write: %s, wrote %d bytes at offset %d", hint, writeLength, circular_->normalizedWritePos() );
a329 1
   void log( const char *format, ... ) {}
d373 1
a373 1
   nameLength_ = _tprintf( nameBuffer_, _T("cpput_%08x_%08x"), pid, id_ );
d380 1
d407 1
d412 1
d446 7
d535 1
d538 2
d587 1
a587 1
      log( "Stopping thread..." );
d591 1
a591 1
      log( "Thread stopped." );
d601 1
a601 1
      log( "Thread started." );
d606 1
a606 1
         log( "Waiting event");
d612 1
a612 1
         log( "Event signaled: %d", event );
d616 1
a616 1
               log( "timeout event !" );
d619 1
a619 1
               log( "event wait failed" );
d622 1
a622 1
               log ("abandonned event: %d!", event );
d627 1
a627 1
            log( "Stop event signaled !" );
d635 1
a635 1
      log( "Thread stopped." );
d639 1
a639 1
      log( "thread aborted: %s", e.what() );
d643 1
a643 1
      log( "thread aborted with an unspecified exception." );
d721 1
a721 1
               log( "read: message size is %d", buffer.messageLength_ );
d734 1
a734 1
               log( "read: message completly received" );
d779 1
a779 1
               log( "write: message size is %d", buffer.messageLength_ );
d791 1
a791 1
               log( "write: message completly sent" );
d867 7
@


1.5
log
@* fixed compilation error on VC 8.0 (AutoHandle was being copied).
@
text
@d384 3
d388 1
d390 3
d394 1
@


1.4
log
@* fixed compilation without RTTI
* revised stringize implementation to allow an additional customization point by overloading toString().
* added test and corrected bug in serialization/packets implementation.
@
text
@d45 1
a45 1
class AutoHandle : public CppTL::NonCopyable
d48 6
a53 1
   AutoHandle( HANDLE handle = 0 )
d58 15
d86 6
a91 3
      if ( handle_ )
         ::CloseHandle( handle_ );
      handle_ = handle;
d95 5
d467 2
a468 1
   handles_.push_back( handle );
@


1.3
log
@* started adding unit tests for opentest
* added serializer unit test squeleton
* fixed some bug in serializer
* added opentesttest project to VS solution.
@
text
@d617 1
a617 1
      buffer.stream_.packets().beginMessage();
d619 1
a619 1
      buffer.stream_.packets().endSerializeMessage();
d665 1
a665 1
               buffer.stream_.packets().beginMessage();
d672 2
a673 2
            buffer.stream_.packets().received( buffer.data_ + buffer.circular_->readPos_, 
                                               toRead );
d678 1
a678 1
               buffer.stream_.packets().endExternalMessage();
d730 1
a730 1
            Pos written = buffer.stream_.packets().send( target, toWrite );
d811 1
a811 1
SharedMemoryTransport::send( const RemoteMessagePtr &message )
@


1.2
log
@* rough implementation of the overall logic, need heavy testing
@
text
@d619 1
a619 1
      buffer.stream_.packets().endMessage();
d678 1
a678 1
               buffer.stream_.packets().endMessage();
@


1.1
log
@Intermediate comit (does not compile). Shared memory transport WIN32 implementation for TestDriver/TestRunner communication. Shared memory region has been setup. Still need to handle exchange of data using the circular buffers and related events.
@
text
@d2 12
a13 10
#include <opentest/remoteinterfaces.h>
#include <cpptl/thread.h>
#include <tchar.h>

#define WIN32_LEAN_AND_MEAN 
#define NOGDI
#define NOUSER
#define NOKERNEL
#define NOSOUND
#include <windows.h>
d69 1
d78 24
d186 1
d193 1
d196 3
d208 32
d242 1
a242 1
      Pos writePos_; // between 0 and 2*size_
d251 1
a251 2
      CircularBuffer writeBuffer_;
      CircularBuffer readBuffer_;
d256 34
d292 1
a292 1
   void setUpReadWriteSystemEvent();
d300 1
d302 5
d309 5
a313 8
   enum {
      readOperation = 0,
      writeOperation = 1
   }

   typedef std::deque<RemoteMessagePtr> MessagesToSend;
   MessagesToSend messagesToSend_;
   CppTL::Mutex messagesToSendLock_
d317 1
a317 2
   NamedEvent readWriteEvents_[2];
   Stream readWriteStreams_[2];
d321 1
d338 1
a338 1
   nameLength_ = _tprintf( nameBuffer_, _T("cpput_%08x_%08x"), pid, id );
d343 1
a343 1
   setUpReadWriteSystemEvent();
d361 1
d376 1
a376 1
   DWORD fileMappingSize = sizeof(SharedData) + 2*config.bufferSize_;
d392 2
a393 2
   initializeCircularBuffer( shared_->readBuffer_ );
   initializeCircularBuffer( shared_->writeBuffer_ );
d414 1
a414 1
SharedMemoryTransportImpl::setSharedMemoryRegion( HANDLE hMapFile )
d430 3
a432 3
   buffer_.size_ = size;
   buffer_.readPos_ = 0;
   buffer_.writePos_ = 0;
d439 1
a439 1
   handlers_.push_back( handle );
d445 1
a445 1
SharedMemoryTransportImpl::setUpReadWriteSystemEvent()
d451 3
d456 1
a456 1
      if ( readWriteEvents_[index].create( nameBuffer_ ) == 0 )
d458 6
d486 17
d518 1
a518 1
                                &SharedMemoryCommunicationManager::threadBootstrap, 
d562 1
a562 2
               System::Win32SystemError error( "wait failed" );
               log( "%s", error.what() );
d568 1
a568 1
         if ( waitObjects_[event] == stopEvent_ )
d576 1
a576 1

d597 2
a598 2
   waitObjects_.push_back( readWriteEvents_[0].get() );
   waitObjects_.push_back( readWriteEvents_[1].get() );
d608 1
a608 1
   MessagesToSend messages;
d611 1
a611 1
      messagesToSend.swap( messages );
d614 1
d617 4
a620 4
      getWriteStream().packets().beginMessage();
      getWriteStream() << messages.front();
      getWriteStream().packets().endMessage();
      messages.pop();
d628 64
a691 1
//         if ( readEvent().isSignaled()  ||  writeEvent().isSignaled()
d694 92
d817 7
d825 2
@

