head	1.6;
access;
symbols;
locks; strict;
comment	@// @;


1.6
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.5;

1.5
date	2006.03.06.22.36.18;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.11.17.16.09;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.06.07.31.42;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.25.11.08.05;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.24.20.12.04;	author blep;	state Exp;
branches;
next	;


desc
@@


1.6
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#include <opentest/remoteinterfaces.h>
#include <opentest/serializer.h>
 
namespace OpenTest {


Stream &operator <<( Stream &stream, MessageId id )
{
   return stream << (unsigned int)id;
}


Stream &operator >>( Stream &stream, MessageId &id )
{
   unsigned int mid;
   stream >> mid;
   id = MessageId(mid);
   return stream;
}

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class RemoteMessage
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
RemoteMessage::RemoteMessage()
{
}

RemoteMessage::RemoteMessage( MessageId id )
   : messageId_( id )
{
}

RemoteMessage::~RemoteMessage()
{
}


void 
RemoteMessage::serialize( Stream &stream )
{
   stream << messageId_;
   doSerialize( stream );
}

inline RemoteMessagePtr makeRemoteMessage( MessageId id )
{
   return RemoteMessagePtr( new RemoteMessage( id ) );
}

inline void unserializeRemoteMessage( RemoteMessagePtr &outMessage, 
                                      MessageId id )
{
   outMessage.reset( new RemoteMessage( id ) );
}


template<class TargetType>
void dispatchRemoteCall( const RemoteMessagePtr &inMessage, 
                         TargetType *target, 
                         void (TargetType::*method)() )
{
   (target->*method)();
}

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// template class SimpleRemoteMessage
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

template<class DataType>
class OPENTEST_API SimpleRemoteMessage : public RemoteMessage
{
public:
   SimpleRemoteMessage()
   {
   }

   SimpleRemoteMessage( MessageId id, const DataType &data )
      : RemoteMessage( id )
      , data_( data )
   {
   }

   DataType data_;

private: // overridden from RemoteMessage
   virtual void doSerialize( Stream &stream ) 
   {
      stream << data_;
   }
};

template<class DataType>
RemoteMessagePtr makeSimpleRemoteMessage( MessageId id, const DataType &data )
{
   return RemoteMessagePtr( new SimpleRemoteMessage<DataType>( id, data ) );
}

template<class DataType>
void unserializeSimpleRemoteMessage( Stream &stream,
                                     RemoteMessagePtr &outMessage, 
                                     MessageId id, 
                                     CppTL::Type<DataType> )
{
   typedef SimpleRemoteMessage<DataType> MessageType;
   MessageType *message = new MessageType();
   outMessage.reset( message );
   stream >> message->messageId_;
   stream >> message->data_;
}


template<class TargetType, class DataType>
class DispatchHelper
{
public:
   static void simpleRemoteCall( const RemoteMessagePtr &inMessage, 
                                 TargetType *target, 
                                 void (TargetType::*method)( const DataType &) )
   {
      typedef SimpleRemoteMessage<DataType> MessageType;
      const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
      (target->*method)( message->data_ );
   }

   static void simpleRemoteCallNoRef( const RemoteMessagePtr &inMessage, 
                                      TargetType *target, 
                                      void (TargetType::*method)( DataType ) )
   {
      typedef SimpleRemoteMessage<DataType> MessageType;
      const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
      (target->*method)( message->data_ );
   }

   static void testIdRemoteCall( const RemoteMessagePtr &inMessage, 
                                 TargetType *target, 
                                 void (TargetType::*method)( TestId, const DataType & ) )
   {
      typedef TestIdRemoteMessage<DataType> MessageType;
      const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
      (target->*method)( message->testId_, message->data_ );
   }
};



// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// template class TestIdRemoteMessage
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

template<class DataType>
class OPENTEST_API TestIdRemoteMessage : public RemoteMessage
{
public:
   TestIdRemoteMessage()
   {
   }

   TestIdRemoteMessage( MessageId id, TestId testId, const DataType &data )
      : RemoteMessage( id )
      , testId_( testId )
      , data_( data )
   {
   }

   DataType data_;
   TestId testId_;

private: // overridden from RemoteMessage
   virtual void doSerialize( Stream &stream ) 
   {
      stream << testId_ << data_;
   }
};

template<class DataType>
RemoteMessagePtr makeTestIdRemoteMessage( MessageId id, TestId test, const DataType &data )
{
   return RemoteMessagePtr( new TestIdRemoteMessage<DataType>( id, test, data ) );
}

template<class DataType>
void unserializeTestIdRemoteMessage( Stream &stream,
                                     RemoteMessagePtr &outMessage, 
                                     MessageId id, 
                                     CppTL::Type<DataType> )
{
   typedef TestIdRemoteMessage<DataType> MessageType;
   MessageType *message = new MessageType();
   outMessage.reset( message );
   stream >> message->messageId_;
   stream >> message->testId_;
   stream >> message->data_;
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// RemoteMessagePtr serialization
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////


Stream & operator <<( Stream &stream, const RemoteMessagePtr &message )
{
   message->serialize( stream );
   return stream;
}

Stream & OPENTEST_API operator >>( Stream &stream, RemoteMessagePtr &message )
{
   message.reset();
   MessageId id;
   stream >> id;
   switch ( id )
   {
   case driverMessageSetTestDescriptions:
      unserializeSimpleRemoteMessage( stream, message, id, CppTL::Type<TestDescriptions>() );
      break;
   case driverMessageSetDefaultTestPlan:
      unserializeSimpleRemoteMessage( stream, message, id, CppTL::Type<TestPlan>() );
      break;
   case driverMessageStartTesting:
      unserializeSimpleRemoteMessage( stream, message, id, CppTL::Type<TestId>() );
      break;
   case driverMessageAddResultLog:
      unserializeTestIdRemoteMessage( stream, message, id, CppTL::Type<ResultLog>() );
      break;
   case driverMessageAddResultAssertion:
      unserializeTestIdRemoteMessage( stream, message, id, CppTL::Type<ResultAssertion>() );
      break;
   case driverMessageSetResultInputActualOutput:
      unserializeTestIdRemoteMessage( stream, message, id, CppTL::Type<ResultInputOutput>() );
      break;
   case driverMessageSetTestResult:
      unserializeTestIdRemoteMessage( stream, message, id, CppTL::Type<ResultStatus>() );
      break;
   case driverMessageTestPlanDone:
      unserializeSimpleRemoteMessage( stream, message, id, CppTL::Type<TestId>() );
      break;
   case runnerMessageRunTests:
      unserializeSimpleRemoteMessage( stream, message, id, CppTL::Type<TestPlan>() );
      break;
   case runnerMessageGetTestDescriptions:
   case runnerMessageGetTestPlans:
   case runnerMessageStopTest:
      unserializeRemoteMessage( message, id );
      break;
   default:
      stream.setError( "Bad message type." );
      break;
   }
   return stream;
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class MessageServerProxy
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

MessageServerProxy::MessageServerProxy()
   : transport_( 0 )
{
}


void 
MessageServerProxy::setTransport( MessageTransport &transport )
{
   transport_ = &transport;
}


void 
MessageServerProxy::sendMessage( const RemoteMessagePtr &message )
{
   if ( transport_ )
      transport_->sendMessage( message );
   else  // @@todo transport error
   {
   }
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class TestDriverProxy
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
void 
TestDriverProxy::setTestDescriptions( const TestDescriptions &tests )
{
   sendMessage( makeSimpleRemoteMessage( driverMessageSetTestDescriptions,
                                         tests ) );
}

void  
TestDriverProxy::setDefaultTestPlan( const TestPlans &plans )
{
   sendMessage( makeSimpleRemoteMessage( driverMessageSetDefaultTestPlan,
                                         plans ) );
}

void  
TestDriverProxy::startTesting( TestPlanId testPlan )
{
   sendMessage( makeSimpleRemoteMessage( driverMessageStartTesting,
                                         testPlan ) );
}


void  
TestDriverProxy::addResultLog( TestPlanId testPlan, 
                               const ResultLog &log )
{
   sendMessage( makeTestIdRemoteMessage( driverMessageAddResultLog,
                                         testPlan,
                                         log ) );
}

void  
TestDriverProxy::addResultAssertion( TestPlanId testPlan, 
                                     const ResultAssertion &assertion )
{
   sendMessage( makeTestIdRemoteMessage( driverMessageAddResultAssertion,
                                         testPlan,
                                         assertion ) );
}

void  
TestDriverProxy::setResultInputActualOutput( TestPlanId testPlan, 
                                             const ResultInputOutput &output )
{
   sendMessage( makeTestIdRemoteMessage( driverMessageSetResultInputActualOutput,
                                         testPlan,
                                         output ) );
}

void  
TestDriverProxy::setTestResult( TestPlanId testPlan, 
                                const ResultStatus &status )
{
   sendMessage( makeTestIdRemoteMessage( driverMessageSetTestResult,
                                         testPlan,
                                         status ) );
}

void  
TestDriverProxy::testPlanDone( TestPlanId id )
{
   sendMessage( makeSimpleRemoteMessage( driverMessageTestPlanDone,
                                         id ) );
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class TestDriverServer
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////

void 
TestDriverServer::dispatchMessage( const RemoteMessagePtr &message )
{
   switch ( message->messageId_ )
   {
   case driverMessageSetTestDescriptions:
      DispatchHelper<TestDriverInterface, TestDescriptions>::simpleRemoteCall( message, 
         impl_, 
         &TestDriverInterface::setTestDescriptions );
      break;
   case driverMessageSetDefaultTestPlan:
      DispatchHelper<TestDriverInterface, TestPlans>::simpleRemoteCall( message, 
         impl_, 
         &TestDriverInterface::setDefaultTestPlans );
      break;
   case driverMessageStartTesting:
      DispatchHelper<TestDriverInterface, TestPlanId>::simpleRemoteCallNoRef( message, 
         impl_, 
         &TestDriverInterface::startTesting );
      break;
   case driverMessageAddResultLog:
      DispatchHelper<TestDriverInterface, ResultLog>::testIdRemoteCall( message, 
         impl_, 
         &TestDriverInterface::addResultLog );
      break;
   case driverMessageAddResultAssertion:
      DispatchHelper<TestDriverInterface, ResultAssertion>::testIdRemoteCall( message, 
         impl_, 
         &TestDriverInterface::addResultAssertion );
      break;
   case driverMessageSetResultInputActualOutput:
      DispatchHelper<TestDriverInterface, ResultInputOutput>::testIdRemoteCall( message, 
         impl_, 
         &TestDriverInterface::setResultInputActualOutput );
      break;
   case driverMessageSetTestResult:
      DispatchHelper<TestDriverInterface, ResultStatus>::testIdRemoteCall( message, 
         impl_, 
         &TestDriverInterface::setTestResult );
      break;
   case driverMessageTestPlanDone:
      DispatchHelper<TestDriverInterface, TestPlanId>::simpleRemoteCallNoRef( message, 
         impl_, 
         &TestDriverInterface::testPlanDone );
      break;
   default:
      // ignore message => @@todo add some error handling
      break;
   }
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class TestRunnerProxy
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
void 
TestRunnerProxy::getTestDescriptions()
{
   sendMessage( makeRemoteMessage( runnerMessageGetTestDescriptions ) );
}

void 
TestRunnerProxy::getTestPlans()
{
   sendMessage( makeRemoteMessage( runnerMessageGetTestPlans ) );
}

void 
TestRunnerProxy::runTests( const TestPlans &plan )
{
   sendMessage( makeSimpleRemoteMessage( runnerMessageRunTests, plan ) );
}

void 
TestRunnerProxy::stopTests()
{
   sendMessage( makeRemoteMessage( runnerMessageStopTest ) );
}


// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// class TestRunnerServer
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
void 
TestRunnerServer::dispatchMessage( const RemoteMessagePtr &message )
{
   switch ( message->messageId_ )
   {
   case runnerMessageGetTestDescriptions:
      dispatchRemoteCall( message, impl_, &TestRunnerInterface::getTestDescriptions );
      break;
   case runnerMessageGetTestPlans:
      dispatchRemoteCall( message, impl_, &TestRunnerInterface::getTestPlans );
      break;
   case runnerMessageRunTests:
      DispatchHelper<TestRunnerInterface, TestPlans>::simpleRemoteCall( message, 
         impl_, 
         &TestRunnerInterface::runTests );
      break;
   case runnerMessageStopTest:
      dispatchRemoteCall( message, impl_, &TestRunnerInterface::stopTests );
      break;
   default:
      // ignore message => @@todo add some error handling
      break;
   }
}


} // namespace OpenTest
@


1.5
log
@* worked-around msvc6 compiler bug.
@
text
@@


1.4
log
@* rough sketch of a working OpenTest driver with CppUT adaptor for TestRunner.
@
text
@d116 21
a136 11
template<class TargetType
        ,class DataType
        >
void dispatchSimpleRemoteCall( const RemoteMessagePtr &inMessage, 
                               TargetType *target, 
                               void (TargetType::*method)( const DataType & ) )
{
   typedef SimpleRemoteMessage<DataType> MessageType;
   const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
   (target->*method)( message->data_ );
}
d138 9
a147 11
template<class TargetType
        ,class DataType
        >
void dispatchSimpleRemoteCallNoRef( const RemoteMessagePtr &inMessage, 
                                    TargetType *target, 
                                    void (TargetType::*method)( DataType ) )
{
   typedef SimpleRemoteMessage<DataType> MessageType;
   const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
   (target->*method)( message->data_ );
}
a200 12
template<class TargetType
        ,class DataType
        >
void dispatchTestIdRemoteCall( const RemoteMessagePtr &inMessage, 
                               TargetType *target, 
                               void (TargetType::*method)( TestId, const DataType & ) )
{
   typedef TestIdRemoteMessage<DataType> MessageType;
   const MessageType *message = static_cast<const MessageType *>( inMessage.get() );
   (target->*method)( message->testId_, message->data_ );
}

d375 3
a377 1
      dispatchSimpleRemoteCall( message, impl_, &TestDriverInterface::setTestDescriptions );
d380 3
a382 1
      dispatchSimpleRemoteCall( message, impl_, &TestDriverInterface::setDefaultTestPlans );
d385 3
a387 1
      dispatchSimpleRemoteCallNoRef( message, impl_, &TestDriverInterface::startTesting );
d390 3
a392 1
      dispatchTestIdRemoteCall( message, impl_, &TestDriverInterface::addResultLog );
d395 3
a397 1
      dispatchTestIdRemoteCall( message, impl_, &TestDriverInterface::addResultAssertion );
d400 3
a402 1
      dispatchTestIdRemoteCall( message, impl_, &TestDriverInterface::setResultInputActualOutput );
d405 3
a407 1
      dispatchTestIdRemoteCall( message, impl_, &TestDriverInterface::setTestResult );
d410 3
a412 1
      dispatchSimpleRemoteCallNoRef( message, impl_, &TestDriverInterface::testPlanDone );
d468 3
a470 1
      dispatchSimpleRemoteCall( message, impl_, &TestRunnerInterface::runTests );
@


1.3
log
@* fixed compilation without RTTI
* revised stringize implementation to allow an additional customization point by overloading toString().
* added test and corrected bug in serialization/packets implementation.
@
text
@d309 1
a309 1
TestDriverProxy::setDefaultTestPlan( const TestPlan &plan )
d312 1
a312 1
                                         plan ) );
d316 1
a316 1
TestDriverProxy::startTesting( TestId testPlan )
d324 1
a324 1
TestDriverProxy::addResultLog( TestId testPlan, 
d333 1
a333 1
TestDriverProxy::addResultAssertion( TestId testPlan, 
d342 1
a342 1
TestDriverProxy::setResultInputActualOutput( TestId testPlan, 
d351 1
a351 1
TestDriverProxy::setTestResult( TestId testPlan, 
d382 1
a382 1
      dispatchSimpleRemoteCall( message, impl_, &TestDriverInterface::setDefaultTestPlan );
@


1.2
log
@Separated serialization process from call dispatching. This allows the serialization to be done by the transport layer (in a single thread). RemoteMessage can be exchanged between thread safely.
@
text
@d31 1
d268 1
a268 1
// class MessageSender
d272 6
d279 1
a279 1
MessageSender::sendMessage( const RemoteMessagePtr &message )
d281 12
d427 1
a427 1
TestRunnerProxy::runTests( const TestPlan &plan )
@


1.1
log
@Remote interface for TestRunner / TestDriver connection (serialize message)
@
text
@d23 244
d271 2
a272 1
void MessageSender::beginMessage( MessageId message )
a273 2
   stream().startsWriteNewMessage();
   stream() << message;
d283 1
a283 1
TestDriverProxy::setTestDescriptions( TestDescriptions &tests )
d285 2
a286 3
   beginMessage( driverMessageSetTestDescriptions );
   stream() << tests;
   sendMessage();
d292 2
a293 3
   beginMessage( driverMessageSetDefaultTestPlan );
   stream() << plan;
   sendMessage();
d299 2
a300 3
   beginMessage( driverMessageStartTesting );
   stream() << testPlan;
   sendMessage();
d308 3
a310 3
   beginMessage( driverMessageAddResultLog );
   stream() << testPlan  <<  log;
   sendMessage();
d317 3
a319 3
   beginMessage( driverMessageAddResultAssertion );
   stream() << testPlan << assertion;
   sendMessage();
d326 3
a328 3
   beginMessage( driverMessageSetResultInputActualOutput );
   stream() << testPlan << output;
   sendMessage();
d333 1
a333 1
                                ResultStatus &status )
d335 3
a337 3
   beginMessage( driverMessageSetTestResult );
   stream() << testPlan << status;
   sendMessage();
d343 2
a344 3
   beginMessage( driverMessageTestPlanDone );
   stream() << id;
   sendMessage();
d355 1
a355 1
TestDriverServer::processMessageStream()
d357 1
a357 3
   MessageId message;
   stream() >> message;
   switch ( message )
d360 1
a360 5
      {
         TestDescriptions tests;
         stream() >> tests;
         impl_->setTestDescriptions( tests );
      }
d363 1
a363 5
      {
         TestPlan plan;
         stream() >> plan;
         impl_->setDefaultTestPlan( plan );
      }
d366 1
a366 5
      {
         TestId testPlan;
         stream() >> testPlan;
         impl_->startTesting( testPlan );
      }
d369 1
a369 6
      {
         TestId testPlan;
         ResultLog log;
         stream() >> testPlan >> log;
         impl_->addResultLog( testPlan, log );
      }
d372 1
a372 6
      {
         TestId testPlan;
         ResultAssertion assertion;
         stream() >> testPlan >> assertion;
         impl_->addResultAssertion( testPlan, assertion );
      }
d375 1
a375 6
      {
         TestId testPlan;
         ResultInputOutput output;
         stream() >> testPlan >> output;
         impl_->setResultInputActualOutput( testPlan, output );
      }
d378 1
a378 6
      {
         TestId testPlan;
         ResultStatus status;
         stream() >> testPlan >> status;
         impl_->setTestResult( testPlan, status );
      }
d381 1
a381 5
      {
         TestId testPlan;
         stream() >> testPlan;
         impl_->testPlanDone( testPlan );
      }
d384 1
a384 1
      stream().setError( "Bad message type." );
d398 1
a398 2
   beginMessage( runnerMessageGetTestDescriptions );
   sendMessage();
d400 1
d404 1
a404 2
   beginMessage( runnerMessageGetTestPlans );
   sendMessage();
d410 1
a410 3
   beginMessage( runnerMessageRunTests );
   stream() << plan;
   sendMessage();
d414 1
a414 1
TestRunnerProxy::stopTest()
d416 30
a445 2
   beginMessage( runnerMessageStopTest );
   sendMessage();
@

