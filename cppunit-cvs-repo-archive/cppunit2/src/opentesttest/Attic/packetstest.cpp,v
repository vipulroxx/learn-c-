head	1.9;
access;
symbols;
locks; strict;
comment	@// @;


1.9
date	2006.09.01.19.27.59;	author blep;	state dead;
branches;
next	1.8;

1.8
date	2006.06.05.12.05.57;	author blep;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.10.21.28.38;	author blep;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.13.10.12.01;	author blep;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.08.23.25.31;	author blep;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.06.07.31.42;	author blep;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.08.22.12.37;	author blep;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.20.21.06.51;	author blep;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.04.08.12.34;	author blep;	state Exp;
branches;
next	;


desc
@@


1.9
log
@- opentest library has been moved to its own project: http://www.sf.net/projects/opentest/
@
text
@#include "packetstest.h"
#include <cpput/assertcommon.h>
#include <cpput/assertstring.h>
#include <cpput/registry.h>
#include <cpptl/scopedptr.h>
#include <memory.h>   // memcmp, memset

class BinaryData
{
public:
   BinaryData( const void *data, unsigned int length )
      : data_( data )
      , length_( length )
   {
   }

   bool operator ==( const BinaryData &other ) const
   {
      return length_ == other.length_  &&
             memcmp( data_, other.data_, length_ ) == 0;
   }

   CppTL::ConstString toString() const
   {
      const char *begin = static_cast<const char *>( data_ );
      return "length = " + CppTL::toString( length_ ) + "\ndata = "
             + CppTL::quoteString( CppTL::ConstString( begin, begin + length_ ) );
   }

   const void *data_;
   unsigned int length_;
};

namespace CppUT {
// converter for assert equal
inline std::string toString( const BinaryData &value )
{
   return value.toString().str();
}
}


CPPUT_REGISTER_SUITE_TO_DEFAULT( PacketsTest )

PacketsTest::PacketsTest()
{
}


PacketsTest::~PacketsTest()
{
}


void 
PacketsTest::setUp()
{
   packets_.reset( new OpenTest::Packets( 4 ) );
}


void 
PacketsTest::tearDown()
{
   packets_.reset();
}


void 
PacketsTest::testDefaultConstructor()
{
   CPPUT_ASSERT_EXPR_FALSE( packets_->hasPendingMessage() );
}


void 
PacketsTest::testSerializeMessage()
{
   static const char *testData[] = { "1", "12", "123", "12345", "1234abcd" };
   static int packetSizes[] = { 1, 2, 3, 4, 5, 16384 };
   const int numberOfTestData = sizeof(testData) / sizeof(const Byte *);
   for ( int size = 0; size < sizeof(packetSizes)/sizeof(int); ++size )
   {
      int packetSize = packetSizes[size];
      CppUT::log( "Using packet size: " + CppTL::toString( packetSize ) );
      packets_.reset( new OpenTest::Packets( packetSize ) );
      for ( int index1 = 0; index1 < numberOfTestData; ++index1 )
      {
         Pos testDataLength = strlen(testData[index1]);
         packets_->beginWriteMessage();
         packets_->write( testData[index1], testDataLength );
         packets_->endWriteMessage();
         CPPUT_ASSERT_EXPR( packets_->hasPendingMessage());
         CppTL::ScopedArray<Byte> actual( new Byte[ testDataLength ] );
         memset( actual.get(), 0, testDataLength );
         Pos actualLength = packets_->read( actual.get(), testDataLength );
         CPPUT_ASSERT_EQUAL( BinaryData( testData[index1], testDataLength ), 
                             BinaryData( actual.get(), actualLength ) );
      }
   }
}


void 
PacketsTest::testDiscardFirstMessage()
{
   // Notes: could have use a loop but loop unrolling makes thing easier for debugging.
   static const char *testData = "12345";
   const int testDataLength1 = 3;
   const int testDataLength2 = 4;
   const int testDataLength3 = 5;
   packets_->beginWriteMessage();
   packets_->write( testData, testDataLength1 );
   packets_->endWriteMessage();

   packets_->beginWriteMessage();
   packets_->write( testData, testDataLength2 );
   packets_->endWriteMessage();

   char buffer1[testDataLength1+1];
   buffer1[testDataLength1] = 0;
   CppUT::log( "Reading message 123" );
   CPPUT_ASSERT_EXPR( packets_->hasPendingMessage() );
   CPPUT_ASSERT_EQUAL( testDataLength1, packets_->getFirstMessageLength() );
   CPPUT_ASSERT_EQUAL( testDataLength1,
                       packets_->read( buffer1, testDataLength1 ) );
   CPPUT_ASSERT_EQUAL( BinaryData( testData, testDataLength1 ),
                       BinaryData( buffer1, testDataLength1 ) );
   packets_->discardFirstMessage();

   packets_->beginWriteMessage();
   packets_->write( testData, testDataLength3 );
   packets_->endWriteMessage();

   char buffer2[testDataLength2+1];
   buffer2[testDataLength2] = 0;
   CppUT::log( "Reading message 1234" );
   CPPUT_ASSERT_EXPR( packets_->hasPendingMessage() );
   CPPUT_ASSERT_EQUAL( testDataLength2, packets_->getFirstMessageLength() );
   CPPUT_ASSERT_EQUAL( testDataLength2,
                       packets_->read( buffer2, testDataLength2 ) );
   CPPUT_ASSERT_EQUAL( BinaryData( testData, testDataLength2 ),
                       BinaryData( buffer2, testDataLength2 ) );
   packets_->discardFirstMessage();

   char buffer3[testDataLength3+1];
   buffer3[testDataLength3] = 0;
   CppUT::log( "Reading message 123" );
   CPPUT_ASSERT_EXPR( packets_->hasPendingMessage() );
   CPPUT_ASSERT_EQUAL( testDataLength3, packets_->getFirstMessageLength() );
   CPPUT_ASSERT_EQUAL( testDataLength3,
                       packets_->read( buffer3, testDataLength3 ) );
   CPPUT_ASSERT_EQUAL( BinaryData( testData, testDataLength3 ),
                       BinaryData( buffer3, testDataLength3 ) );
   packets_->discardFirstMessage();
}
@


1.8
log
@* a bit of clean-up
@
text
@@


1.7
log
@* added unit test for Packets::discardFirstMessage() and fixed bug in Packets.
@
text
@a119 4
   packets_->beginWriteMessage();
   packets_->write( testData, testDataLength3 );
   packets_->endWriteMessage();

d131 4
@


1.6
log
@- renamed include/cpput/assert.h to include/cpput/assertcommon.h. This avoid clash with include <assert.h> in doxygen documentation
- most Impl namespaces are now hidden from documentation using \cond and \endcond.
@
text
@d102 55
@


1.5
log
@- fixed static registration macro for Registry
- static registration macros must no longer be followed by a semi-colon
  (therefore we get compiler error if registry.h was not included)
- allow registration macros to work with class implenting suite() or suite( const std::string &).
@
text
@d2 1
a2 1
#include <cpput/assert.h>
@


1.4
log
@* fixed compilation without RTTI
* revised stringize implementation to allow an additional customization point by overloading toString().
* added test and corrected bug in serialization/packets implementation.
@
text
@d43 1
a43 1
CPPUT_REGISTER_SUITE_TO_DEFAULT( PacketsTest );
@


1.3
log
@* Fixed msvc6 compilation issue
@
text
@d4 1
d36 1
a36 1
inline std::string convertToString( const BinaryData &value )
d43 2
d80 1
d82 1
a82 1
   for ( int index1 = 0; index1 < numberOfTestData; ++index1 )
d84 16
a99 11
      Pos testDataLength = strlen(testData[index1]);
      packets_.reset( new OpenTest::Packets( 4 ) ); // notes: test fails if using the same packets...
      packets_->beginMessage();
      packets_->serializationWrite( testData[index1], testDataLength );
      packets_->endSerializeMessage();
      CPPUT_ASSERT_EXPR( packets_->hasPendingMessage() );
      CppTL::ScopedArray<Byte> actual( new Byte[ testDataLength ] );
      memset( actual.get(), 0, testDataLength );
      Pos actualLength = packets_->send( actual.get(), testDataLength );
      CPPUT_ASSERT_EQUAL( BinaryData( testData[index1], testDataLength ), 
                          BinaryData( actual.get(), actualLength ) );
@


1.2
log
@* Added IntrusivePtr, a reference counted smart-pointer
* Changed Test hierarchy and TestFixture to use IntrusivePtr instead of SharedPtr (this allows simple upcasting).
@
text
@d26 1
a26 1
             + quoteString( CppTL::ConstString( begin, begin + length_ ) );
@


1.1
log
@* Started adding unit tests for Packets.
@
text
@d81 1
@

